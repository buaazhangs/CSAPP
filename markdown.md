**记录内容，大标题为课程分段，小标题为每一节课**<br>
**重要内容：记录课程主题**<br>
**有部分了解的内容：记录重点**<br>
**记录实验**<br>
# Lecture1<br>
## 位运算第一课  
### 补码
<< ：左移<br>>>：逻辑，算术右移  
二进制表示无符号数UB，补码数TB与十进制数的转换关系：
<img src="markdown图片/屏幕截图 2023-10-30 174956.png" alt="图片alt" title="图片title"><br>
具体解析补码数：<br>
补码数的形成（即正常数得到补码），例如计算机表示-10：<br>
提前告知-10的补码是10110，利用B2T,即-16+4+2=-10，B2T即为补码转为正常十进制数关系，而如果这是一个无符号数，则B2U，即16+4+2=22<br>
另外我们也可以看到，正数的补码与其无符号数表示相同<br>
那么怎么得到-10的补码?<br>
首先获取10的无符号数表示，为1010，再用10000-01010=00110，再将头位改为1即可，即10110<br>
实际操作中，10000-01010这一步计算方法为：<br>
01111-01010+00001,所以实际做法为01010求反，然后+1即可<br>
**实际上，取反+1也可用于补码表示的数的正负互相转换**  
另外，01111表示15.10000表示-16，因此溢出后再加一位即溢出到符号位上了<br>
### 比较
无符号数比较按位比较，例如10000大于01111，因此，需要考虑比较数据的类型
因此，-1补码11111，0unsigned和补码均为00000，会出现-1大于0，C中隐式转换会将有符号数和无符号数一起参与的情况时都视为无符号数，因此此时11111视为31，31大于0，所以要比较-1和0unsigned，需要转换0为signed，此时比较会考虑符号数（当然，不同符号数还要不同的比较后面的值）
### 关于补码的不对称性
对于10000，即-16，发现并没有同样位数长度的正数补码与其对应
### 越界
#### 回绕
unsigned i = 0，i--这种视为回绕，这种情况为00000-1=11111
#### 非回绕
int i = 01111为15，i++，这种并非回绕，01111+1=10000为-16，这种变化是补码性质决定的，11111(-1)++变为00000这种才是回绕
### 相关编程cornercase
1. sizeof(char),sizeof返回unsigned，因此要注意int与其的运算<br>
2. 



### 补码数扩展与截断
4位补码，不变化其值扩展为8位：复制符号位即可<br>
1111->11111111,均为-1，原-16，变为-32+16，再-64+32<br>
补码截断似乎没有特别规律？

## 整数运算<br>
### unsigned<br>
上面说到底越界回绕，实际上是计算机处理位数运算时的截断，例如4位的unsigned的a和b，a+b的结果实际为：<br>
a+b = (a+b) mod 2^4  
### 补码运算<br>
补码运算直接相加减能得到正确的补码值，why？<br>
首先考虑到不溢出到符号位的情况，即4为int，表示-8到7情况下，结果也在-8到7，这种情况的第5位正常截断，不影响结果<br>
再考虑溢出到符号位的情况，会出现正overflow和负overflow
<img src="markdown图片/屏幕截图 2023-10-31 115825.png" alt="图片alt" title="图片title"><br>
  
### 乘除运算
无论无符号还是有符号，都存在discord，因此情况要有趣很多，同样，无符号数的截获可以视为mod，但是有符号没那么简单<br>
例如5*5=25，为  
00011001，截断为1001，即-7，变为负数了  
当然上述为溢出的情况，如果不溢出，例如-3*-2得到6，结果将是对的。

### 位运算  
<<左移  >>右移  
注意补码负数的右移<br>
算数右移：符号位不动，高位补1，因此对于负数补码运算，绝大多数机器的>>是算数右移，
逻辑右移，高位补0，适用于unsigned和正数补码
## 总结
1. 遇到溢出，根本考虑的是截断discord<br>
对于补码，影响到符号位也是一个“溢出”考虑因素  
## data in memory  
### 字长
一次取址的长度，32位机器或者64位机器
### 字节序
一个类型占据多个字节时，按照什么顺序存储。  
little endian：小端，从低地址开始存储<br>
大端相反,目前，大端基本只用在internet传输中<br>
for example,对于0x01234567<br>
big endian为01 23 45 67
little endian为67 45 23 01
### 字符序
string本质由一堆char构成，因此string可以被看做一种大端序（实际上不需要顺序）

## 练习题
注意比较，计算时无符号数优先<br>
ans：
1. f 
2. t 
3. t 
4. f
5. f:tmin,即-8的负，这种情况仍然用取反+1，1000取反+1仍为1000，因此-tmin = tmin
6. f
7. f
8. t
9. f,与上面不同，有tmin  
<img src="markdown图片/屏幕截图 2023-10-31 210557.png" alt="图片alt" title="图片title"><br>

## 浮点数  
### 局限性
2进制小数不能表示所有十进制小数，其只能表示x/2^k的有理数，即该小数可以被写为2^-i的展开<br>
某些数，如0.2这种就不能被2进制表示，只能在一定精度下表示<br>
**因此，浮点含义即为在表示大小范围和表示精度直接移动小数点获取平衡**<br>
### 标准表示
f = (-1)^s * M * 2^E这样的数,M：mantissa尾数，E:exponent指数，幂<br>
编码表示如下：
s   exp     frac  
其中s即符号位，s == s 1bit  
exp部分的多个位编码了E 注意exp != E 8bit<br>
frac部分编码了M，同样frac不直接等于M  23bit<br>
### 编码方式：
E = exp - bias,exp为exp为构成的正数值<br>
exp 8bit 下范围为0-255，然鹅还有不为全0和全1限制 **(全0全1特殊类型)**，因此范围是1-254<br>
bias固定为2^(k-1)-1 = 127<br>
因此E的范围为-126-127<br><br>
M = 1.xxxx<br>
xxxx = frac位表示的2进制小数<br>
**例如，frac为110，即表示2^-1*1+2^-2*1=6/8<br>
M = 1+6/8**
### 样例  
表示15213.0：
15213.0 = 1.1101101101101 * 2^13<br>
因此有M = 1.1101101101101,那么<br>
frac = 11011011011010000000000<br>
E = 13,所以exp = 13+bias(127)=140,即<br>
10001100  
可以看到即科学计数法
### 非标准浮点数 
**(M设定为1-2是因为指数部分为2^k，因此M为1-2，正常情况下不用考虑0-1，因为0.5*2^4 = 1 *2^3)**<br>
**但是，对于2^-126的情况，没有-127了，因此需要考虑M部分为0-1了**<br>
因此，此时E = 1 - bias，M = 0.xxxxx(原因可以见后图)
### 特殊类型
exp全1，frac全0，视为inf；  
exp全1，frac不全0，即not a number(NaN);<br>
exp全0，即为非标准浮点数(可见后图)
### 重要图
范围图
<img src="markdown图片/屏幕截图 2023-11-01 160434.png" alt="图片alt" title="图片title"><br>
概括性值图
<img src="markdown图片/屏幕截图 2023-11-01 161302.png" alt="图片alt" title="图片title"><br>
数轴上表达值
<img src="markdown图片/屏幕截图 2023-11-01 164207.png" alt="图片alt" title="图片title"><br>

### 浮点数的运算
#### 舍入round：<br>
向最近数（中间向偶数）舍入法：<br>
1.4->1,1.5->2,0.5->0,0.6->1。  
上面的数中，除了中间的均近邻舍入，中间的如.5,向最近的偶数舍入<br>
浮点数有很多无法表示的数，因此需要舍入：  
方法是将该数写出来，然后向能表示的值舍入，这就必然涉及到中间数。  
for example：  
对于只能表示1/4的，10.11 and 11.00 的中间数即为：  
10.11100，11.00更是所谓二进制偶数，因此10.11100舍入到11.00.  
这种舍入是浮点数运算的根本，影响到了他的许多性质。例如不符合结合律等。
#### 加与乘：


### 浮点与int转换：
遵循discord原则，都是先假设有无限长的位可用，再截断到要求的位
### some puzzle：


# 实验：
datalab实验，我们需要修改bits.c文件实现  <br>  
dlc文件:查询bits.c是否符合要求  
./dlc bits.c or ./dlc -e bits.c<br>
编译的btest可执行文件，可对bits.c正确性进行分析
