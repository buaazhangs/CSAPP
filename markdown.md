**记录内容，大标题为课程分段，小标题为每一节课**<br>
**重要内容：记录课程主题**<br>
**有部分了解的内容：记录重点**<br>
**记录实验**<br>
# Lecture1<br>
## 位运算第一课  
### 补码
<< ：左移<br>>>：逻辑，算术右移  
二进制表示无符号数UB，补码数TB与十进制数的转换关系：
<img src="markdown图片/屏幕截图 2023-10-30 174956.png" alt="图片alt" title="图片title"><br>
具体解析补码数：<br>
补码数的形成（即正常数得到补码），例如计算机表示-10：<br>
提前告知-10的补码是10110，利用B2T,即-16+4+2=-10，B2T即为补码转为正常十进制数关系，而如果这是一个无符号数，则B2U，即16+4+2=22<br>
另外我们也可以看到，正数的补码与其无符号数表示相同<br>
那么怎么得到-10的补码?<br>
首先获取10的无符号数表示，为1010，再用10000-01010=00110，再将头位改为1即可，即10110<br>
实际操作中，10000-01010这一步计算方法为：<br>
01111-01010+00001,所以实际做法为01010求反，然后+1即可<br>
**实际上，取反+1也可用于补码表示的数的正负互相转换**  
另外，01111表示15.10000表示-16，因此溢出后再加一位即溢出到符号位上了<br>
### 比较
无符号数比较按位比较，例如10000大于01111，因此，需要考虑比较数据的类型
因此，-1补码11111，0unsigned和补码均为00000，会出现-1大于0，C中隐式转换会将有符号数和无符号数一起参与的情况时都视为无符号数，因此此时11111视为31，31大于0，所以要比较-1和0unsigned，需要转换0为signed，此时比较会考虑符号数（当然，不同符号数还要不同的比较后面的值）
### 关于补码的不对称性
对于10000，即-16，发现并没有同样位数长度的正数补码与其对应
### 越界
#### 回绕
unsigned i = 0，i--这种视为回绕，这种情况为00000-1=11111
#### 非回绕
int i = 01111为15，i++，这种并非回绕，01111+1=10000为-16，这种变化是补码性质决定的，11111(-1)++变为00000这种才是回绕
### 相关编程cornercase
1. sizeof(char),sizeof返回unsigned，因此要注意int与其的运算<br>
2. 



### 补码数扩展与截断
4位补码，不变化其值扩展为8位：复制符号位即可<br>
1111->11111111,均为-1，原-16，变为-32+16，再-64+32<br>
补码截断似乎没有特别规律？

## 整数运算<br>
### unsigned<br>
上面说到底越界回绕，实际上是计算机处理位数运算时的截断，例如4位的unsigned的a和b，a+b的结果实际为：<br>
a+b = (a+b) mod 2^4  
### 补码运算<br>
补码运算直接相加减能得到正确的补码值，why？<br>
首先考虑到不溢出到符号位的情况，即4为int，表示-8到7情况下，结果也在-8到7，这种情况的第5位正常截断，不影响结果<br>
再考虑溢出到符号位的情况，会出现正overflow和负overflow
<img src="markdown图片/屏幕截图 2023-10-31 115825.png" alt="图片alt" title="图片title"><br>
  
### 乘除运算
无论无符号还是有符号，都存在discord，因此情况要有趣很多，同样，无符号数的截获可以视为mod，但是有符号没那么简单<br>
例如5*5=25，为  
00011001，截断为1001，即-7，变为负数了  
当然上述为溢出的情况，如果不溢出，例如-3*-2得到6，结果将是对的。

### 位运算  
<<左移  >>右移  
注意补码负数的右移<br>
算数右移：符号位不动，高位补1，因此对于负数补码运算，绝大多数机器的>>是算数右移，
逻辑右移，高位补0，适用于unsigned和正数补码
## 总结
1. 遇到溢出，根本考虑的是截断discord<br>
对于补码，影响到符号位也是一个“溢出”考虑因素  
## data in memory  
### 字长
一次取址的长度，32位机器或者64位机器
### 字节序
一个类型占据多个字节时，按照什么顺序存储。  
little endian：小端，从低地址开始存储<br>
大端相反,目前，大端基本只用在internet传输中<br>
for example,对于0x01234567<br>
big endian为01 23 45 67
little endian为67 45 23 01
### 字符序
string本质由一堆char构成，因此string可以被看做一种大端序（实际上不需要顺序）

## 练习题
注意比较，计算时无符号数优先<br>
ans：
1. f 
2. t 
3. t 
4. f
5. f:tmin,即-8的负，这种情况仍然用取反+1，1000取反+1仍为1000，因此-tmin = tmin
6. f
7. f
8. t
9. f,与上面不同，有tmin  
<img src="markdown图片/屏幕截图 2023-10-31 210557.png" alt="图片alt" title="图片title"><br>

## 浮点数运算