**记录内容，大标题为课程分段，小标题为每一节课**<br>
**重要内容：记录课程主题**<br>
**有部分了解的内容：记录重点**<br>
**记录实验**<br>
# Lecture1<br>
## 位运算第一课  
### 补码
<< ：左移<br>>>：逻辑，算术右移  
二进制表示无符号数UB，补码数TB与十进制数的转换关系：
<img src="markdown图片/屏幕截图 2023-10-30 174956.png" alt="图片alt" title="图片title"><br>
具体解析补码数：<br>
补码数的形成（即正常数得到补码），例如计算机表示-10：<br>
提前告知-10的补码是10110，利用B2T,即-16+4+2=-10，B2T即为补码转为正常十进制数关系，而如果这是一个无符号数，则B2U，即16+4+2=22<br>
另外我们也可以看到，正数的补码与其无符号数表示相同<br>
那么怎么得到-10的补码?<br>
首先获取10的无符号数表示，为1010，再用10000-01010=00110，再将头位改为1即可，即10110<br>
实际操作中，10000-01010这一步计算方法为：<br>
01111-01010+00001,所以实际做法为01010求反，然后+1即可<br>
另外，01111表示15.10000表示-16，因此溢出后再加一位即溢出到符号位上了<br>
### 比较
无符号数比较按位比较，例如10000大于01111，因此，需要考虑比较数据的类型
因此，-1补码11111，0unsigned和补码均为00000，会出现-1大于0，C中隐式转换会将有符号数和无符号数一起参与的情况时都视为无符号数，因此此时11111视为31，31大于0，所以要比较-1和0unsigned，需要转换0为signed，此时比较会考虑符号数（当然，不同符号数还要不同的比较后面的值）
### 关于补码的不对称性
对于10000，即-16，发现并没有同样位数长度的正数补码与其对应
### 越界
#### 回绕
unsigned i = 0，i--这种视为回绕，这种情况为00000-1=11111
#### 非回绕
int i = 01111为15，i++，这种并非回绕，01111+1=10000为-16，这种变化是补码性质决定的，11111(-1)++变为00000这种才是回绕
### 相关编程cornercase
1. sizeof(char),sizeof返回unsigned，因此要注意int与其的运算<br>
2. 



### 补码数扩展与截断
4位补码，不变化其值扩展为8位：复制符号位即可<br>
1111->11111111,均为-1，原-16，变为-32+16，再-64+32<br>
补码截断似乎没有特别规律？

## 整数运算