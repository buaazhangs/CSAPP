# 并发编程
常见的并发编程问题：
<img src="markdown图片/屏幕截图 2024-03-13 213353.png" alt="图片alt" title="图片title"><br>
迭代服务器：<br>
<img src="markdown图片/屏幕截图 2024-03-13 220442.png" alt="图片alt" title="图片title"><br>
其中，客户端2的write不会阻塞，服务器的内核（TCP协议）会维护一个写入的队列，客户端2的read会阻塞。<br>
另外，客户端1一直未发出close，这导致服务器也被客户端1阻塞。
PS；服务器被阻塞情况下，仍可能允许客户端连入，这些时候客户端的connect或者read等被阻塞，客户端可连入的上线取决于主机的TCP协议。

# 三种并发编程方法
<img src="markdown图片/屏幕截图 2024-03-14 193413.png" alt="图片alt" title="图片title"><br>

## 1. 基于多进程的并发编程
多进程服务器：<br>
<img src="markdown图片/屏幕截图 2024-03-14 195103.png" alt="图片alt" title="图片title"><br>
这种并发的优劣：<br>
<img src="markdown图片/屏幕截图 2024-03-14 195635.png" alt="图片alt" title="图片title"><br>
优点：<br>
1. 实现并发多连接
2. 利用进程的私有地址空间，实现了文件描述符，全局变量的**内存**中的私有，完全隔离，**注意不是硬盘的隔离**（另外注意打开文件表是相同的**（注意是打开文件表不是文件描述符，文件描述符在fork时才是一定一样的）**）<br>

劣势：<br>
1. 开销大
2. 不易共享缓存（需要用进程间通信，或者内存映射）

## 2.基于IO多路复用的并发
假如设计一个这样的服务器，它能对服务器自己的标准输入输出交互命令做出回应，也就是说，它的功能需要能处理字节的IO，那么，假如此时自己要写入信息，另有用户想要连接，这时应优先等待哪个事件？1.先等待用户输入，那么此时用户输入会阻塞其他任务，包括任何其他连接请求2.先等待客户连接，那么此时不能响应任何一个输入命令。<br>

**文件描述符可读：**<br>
当客户端发送的字节成功到达服务器，服务器该客户端的连接描述符所绑定的socket缓存（位于内存）有数据时，就意味着读该文件描述符不会堵塞。对于非网络连接的文件描述符，即该文件描述符所对应的内存或缓存或标准IO。<br>

### 利用select，读集合和准备好读集合实事件驱动：
<img src="markdown图片/屏幕截图 2024-03-14 215219.png" alt="图片alt" title="图片title"><br>
读集合，可以理解为该集合对应的文件为内核监控的，准备好读集合，可以理解为该集合的文件描述符可读。**select持续阻塞知道读集合中有准备好读项**<br>

因此，上述利用select可以解决事件等待问题，但是，例如如果客户端连续发送大量数据，则标准输入仍得不到相应，**不管怎么说，这一服务器都得等客户端完全发送完信息，才能close，也就是说仍有可能阻塞在客户端**所以，对于这种问题解决方案是考虑更细粒度的多路复用，例如一次只从客户端或者标准IO读取一个文本行就结束。

**甚至，即使只读取一个文本行细粒度的，都有可能被阻塞，因为客户端可能只发送部分行（没有\n），因此最合理的方式是服务器读取当前文件描述符的所有可读数据**


优缺点：<br>
<img src="markdown图片/屏幕截图 2024-03-18 211249.png" alt="图片alt" title="图片title"><br>
优点：<br>
1. 单个逻辑流，单个进程，方便理解，共享地址空间，方便共享数据；方便调试。
2. 没有多进程并发服务器的上下文切换开销
缺点：<br>
1. 事件划分等因素使得代码设计更复杂
2. 实际上并没有提升时间效率
3. 因此也无法使用多核加速

## 3. 基于线程的并发
进程与线程的区别：<br>
<img src="markdown图片/屏幕截图 2024-03-19 193801.png" alt="图片alt" title="图片title"><br>
左边为进程上下文，右边为进程在内存中的空间（不删除进程不会删去），如程序段，栈，堆等。<br>
**注意其中进程context和内核context的区别：**<br>
1. 进程上下文，基本可以理解为寄存器值，在该进程运行时这些寄存器值在相应寄存器内，非该进程运行时这些寄存器存到内核的进程控制块中（位于进程内存的内核空间的内核栈）
2. 内核上下文，如页表，文件描述符秒，堆指针等，这些一直都位于进程的内核空间内，一般程序位于内核模式时需要里面的信息
3. 切换进程时的上下文切换，主要指的是把进程上下文部分，这些存在内核空间的内核栈的数据放回寄存器。
4. 内核切换本质上需要切换页表，以能够访问进程所在的物理地址，每个进程的页表的位置存储在进程控制块中**（自然的，这一部分属于全体进程共有）**，在切换进程时，将进程控制块存储的页表基址寄存器值放出来，该寄存器存储着页表的物理地址<br>
线程：<br>
<img src="markdown图片/屏幕截图 2024-03-19 193843.png" alt="图片alt" title="图片title"><br>
可以看到线程上下文基本可以视为进程上下文，以及内存中的栈，也就是说，线程，栈指针，以及这些寄存器。**实际上，线程真正独有的仅为寄存器**<br>
**理论上线程独有栈，但实际上栈依然全部位于进程的栈段，只是理论的被划分为不同的空间，因此线程上下文切换不会切换栈，只切换寄存器**
<img src="markdown图片/屏幕截图 2024-03-19 202832.png" alt="图片alt" title="图片title"><br>
线程共享所在进程的虚拟内存空间，包括代码，数据，堆等，**实际上，一个线程理论上能够访问进程中的任意位置，也就是说，包括其他线程的栈**<br>

### posix thread
1. 创建线程以及线程例程（线程的代码和本地数据）
2. 终止线程，终止其他线程
3. 等待其他线程终止<br>
   pthread_join,等待指定tid线程终止，将tid的线程例程返回的通用对象指针赋值到\*\*thread指向的位置，然后回收该线程的资源
4. 分离线程：<br>
   可结合线程：<br>
   这种线程能被其他线程回收或杀死，在回收之前，这种线程的资源是不会释放的。<br>
   分离的线程：<br>
   这种线程不能被其他线程杀死，它的内存在其终止时由内核自动释放。<br>
5. 初始化线程状态

### 基于线程的并发服务器
要点：<br>
1. 多线程程序的竞争问题，为客户端服务的对等线程实际使用的是主线程上的连接描述符，所以如果主线程的连接描述符在栈上，由于线程运行顺序不确定，就有可能主线程链接描述符会是下一个access的结果。**因此需要在主线程堆上**
只需考虑下面两个程序：<br>
while(1){
   a = 1;
}
while(1){
   a = malloc(sizeof(int));
}

2. 避免内存泄漏问题

# 同步
控制线程执行顺序的技术,如何处理多线程共享变量的问题<br>

## 多线程程序中的共享变量
<img src="markdown图片/屏幕截图 2024-03-21 203056.png" alt="图片alt" title="图片title"><br>
注意，理论上线程可以访问进程内部的任意数据，所以只要什么形式变量x被多个线程无论以什么方式引用，这个x都是共享变量。<br>
变量类型：
1. 全局变量，虚拟内存的读写区域只包含全局变量的一个实例
2. 本地栈上变量，函数内部没有static属性的变量，每个线程的栈都有它所有本地自动变量的实例
3. 本地静态变量，虚拟内存的读写区域只包含在该进程的每个本地静态变量的一个实例。

## 竞争
<img src="markdown图片/屏幕截图 2024-03-22 163137.png" alt="图片alt" title="图片title"><br>
主要原因出在寄存器写入内存（缓存）和从内存（缓存）读的不一致性。**从汇编角度看每一步的操作：**
<img src="markdown图片/屏幕截图 2024-03-24 112407.png" alt="图片alt" title="图片title"><br>

## 进度图
将n个并发线程执行模型转化为n维笛卡尔空间的轨迹。每个轴作为某个线程的进度，每一个坐标作为每个线程的某个指令。<br>
根据线程执行的原理，每一步只有一个线程向前进，但可以是任何一个线程（即不会有对角线）<br>

临界区：<br>
<img src="markdown图片/屏幕截图 2024-03-24 121240.png" alt="图片alt" title="图片title"><br>
操作共享变量的指令构成**临界区**，**这个临界区不应该和其他线程的临界区交替执行**，因此我们希望每个线程执行他自己临界区的指令时，拥有对共享变量**互斥(mutual exclusion)互相排斥**的访问。<br>
**边界**：<br>
临界区的边界是安全的，内部（不包括边界才是危险的），设想：H2H1状态，往右边走，只要不进入就没有L2，就是安全的。<br>
为了保证这种并发执行的正确实现，必须以某种方式同步<br>

## 用信号量同步线程
信号量是一个具有非负整数值的全局变量，只能由PV两个操作来处理。有二元信号量和计数信号量两种<br>
以提供互斥为目的的二元信号量常被称为互斥锁。<br>

**注意，以下两个操作都是原子的，即不可被打断。另外，P和V都会涉及到系统调用。**<br>

设s为信号量，则：<br>
**P**:若s非零，则P将s--并立即返回。如果s为0，则挂起这个线程，直到s变为非0（注意，此时属于该线程被挂起，即该线程被放到内核态的等待队列中），**注意，此时仍在P操作中**，当该线程从等待队列中被重启后（例如，V操作执行），P继续执行，执行操作为s--，然后将控制返回给调用P函数的线程。

**V**:将s++，如果此时有任何线程阻塞在P操作等待s非0，那V操作会重启其中某一个，然后该线程将s--，完成其p操作。

![alt text](<markdown图片/屏幕截图 2024-03-24 155817.png>)<br>
如上图，实现用信号量完成互斥。