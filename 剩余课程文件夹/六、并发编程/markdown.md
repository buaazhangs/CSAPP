# 并发编程
常见的并发编程问题：
<img src="markdown图片/屏幕截图 2024-03-13 213353.png" alt="图片alt" title="图片title"><br>
迭代服务器：<br>
<img src="markdown图片/屏幕截图 2024-03-13 220442.png" alt="图片alt" title="图片title"><br>
其中，客户端2的write不会阻塞，服务器的内核（TCP协议）会维护一个写入的队列，客户端2的read会阻塞。<br>
另外，客户端1一直未发出close，这导致服务器也被客户端1阻塞。
PS；服务器被阻塞情况下，仍可能允许客户端连入，这些时候客户端的connect或者read等被阻塞，客户端可连入的上线取决于主机的TCP协议。

# 三种并发编程方法
<img src="markdown图片/屏幕截图 2024-03-14 193413.png" alt="图片alt" title="图片title"><br>

## 1. 基于多进程的并发编程
多进程服务器：<br>
<img src="markdown图片/屏幕截图 2024-03-14 195103.png" alt="图片alt" title="图片title"><br>
这种并发的优劣：<br>
<img src="markdown图片/屏幕截图 2024-03-14 195635.png" alt="图片alt" title="图片title"><br>
优点：<br>
1. 实现并发多连接
2. 利用进程的私有地址空间，实现了文件描述符，全局变量的**内存**中的私有，完全隔离，**注意不是硬盘的隔离**（另外注意打开文件表是相同的**（注意是打开文件表不是文件描述符，文件描述符在fork时才是一定一样的）**）<br>

劣势：<br>
1. 开销大
2. 不易共享缓存（需要用进程间通信，或者内存映射）

## 2.基于IO多路复用的并发
假如设计一个这样的服务器，它能对服务器自己的标准输入输出交互命令做出回应，也就是说，它的功能需要能处理字节的IO，那么，假如此时自己要写入信息，另有用户想要连接，这时应优先等待哪个事件？1.先等待用户输入，那么此时用户输入会阻塞其他任务，包括任何其他连接请求2.先等待客户连接，那么此时不能响应任何一个输入命令。<br>

**文件描述符可读：**<br>
当客户端发送的字节成功到达服务器，服务器该客户端的连接描述符所绑定的socket缓存（位于内存）有数据时，就意味着读该文件描述符不会堵塞。对于非网络连接的文件描述符，即该文件描述符所对应的内存或缓存或标准IO。<br>

### 利用select，读集合和准备好读集合实事件驱动：
<img src="markdown图片/屏幕截图 2024-03-14 215219.png" alt="图片alt" title="图片title"><br>
读集合，可以理解为该集合对应的文件为内核监控的，准备好读集合，可以理解为该集合的文件描述符可读。**select持续阻塞知道读集合中有准备好读项**<br>

因此，上述利用select可以解决事件等待问题，但是，例如如果客户端连续发送大量数据，则标准输入仍得不到相应，所以，对于这种问题解决方案是考虑更细粒度的多路复用，例如一次只从客户端或者标准IO读取一个文本行。

