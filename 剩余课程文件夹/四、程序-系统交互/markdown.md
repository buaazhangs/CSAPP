# 链接

静态链接：<br>
<img src="markdown图片/屏幕截图 2023-11-20 210611.png" alt="图片alt" title="图片title"><br>

## 链接器(linker)做了什么：
1. 符号解析<br>
   <img src="markdown图片/屏幕截图 2023-11-20 213510.png" alt="图片alt" title="图片title"><br>
   将各个文件的符号（**全局变量与函数和静态变量**）和他们的引用以结构形式存储在符号表中。<br>
   问题：<br>
   假如不同文件有不同的符号定义，linker需要确定哪一个是用于后续引用的。<br>
2. 重定位
   <img src="markdown图片/屏幕截图 2023-11-20 214643.png" alt="图片alt" title="图片title"><br>
   单一目标的汇编文件中，程序中的各个函数，数据地址只是在该模块中的偏移量，由于地址随机化的原因，不能给出某个模块的绝对地址，因此，重定位的目的是将每个符号定义与每个内存位置关联起来，然后修改符号定义的所有引用，使其指向这些位置。<br>
3. 文件介绍：
   <img src="markdown图片/屏幕截图 2023-11-20 215501.png" alt="图片alt" title="图片title"><br>
   可重定位目标.o文件（二进制文件），链接器链接后产生的可执行文件.out，可共享库文件.so。<br>

## 细节：
   上述几个文件的细节：<br>
1. 可重定位目标文件：由各个字节块组成，指令在一个字节块中，初始化的全局变量在另一块字节序列中，未初始化的又在另外一块中。即单个文件编译后的不同块中，有的包含指令，有的包含目标数据。
2. 可执行目标文件：链接器产生的文件，可以直接被复制到内存中执行。
3. 共享目标文件：一种特殊类型的可重定位目标文件，可在加载和运行时被动态的加载进内存并链接。

### ELF文件格式：
**ELF，可执行，可链接文件的字节序列格式。**<br>
<img src="markdown图片/屏幕截图 2023-11-21 111026.png" alt="图片alt" title="图片title"><br>
补充说明：
1. segment header table（可执行文件必须有）：提供了下列各节的地址和大小，指出了代码不同段在内存中的位置。

下一部分，符号表部分：<br>
<img src="markdown图片/屏幕截图 2023-11-21 113613.png" alt="图片alt" title="图片title"><br>

### 符号
解析前面说的符号:<br>
<img src="markdown图片/屏幕截图 2023-11-21 152454.png" alt="图片alt" title="图片title"><br>
补充说明：<br>
链接器主要负责一下三种符号,**注意局部栈变量由编译器管理，利用栈解决，不属于链接器管理，也因此不在符号表中** <br>
会在符号表中的符号：<br>
1. global symbols：全局符号<br>
   **指在该模块中，定义的可被各模块都可使用的全局函数或变量**。因此，在单一模块编译时，即使某个符号未定义，编译器也不会报错，会认为是在其他模块具体定义的。

2. external symbols：外部符号<br>
   **指该模块引用了，但是在别的模块定义的符号**
3. local symbols：本地符号<br>
   指加了static的**全局**变量和函数，这就是static的作用，这使得该全局变量只能在本模块使用，不能链接到其他模块。<br>
4. 补充，static修饰的局部变量，也会在符号表中：它实际上是一个全局变量，被存在data或bss中（根据初始化与否），但是作用域有只在局部的变量。<br>

## 1.符号解析流程
1. 首先解析符号属性
2. 解析符号强弱，未初始化的变量被认为是弱的，函数和初始化的变量被认为是强的。**因此，多种同名符号，链接器会选择一个强符号，然后其他的弱符号链接到它上面，作为它的引用；所以只能有一个同名的强符号，有多个会报错。**<br>
另外，由多个同名弱符号无强符号的情况，链接器会随机选择一个作为定义，这明显会出现问题，尤其不同模块相同名称类型不同的情况（详见符号表结构）；因此在gcc加入no-common来报错避免该情况。但总的来说，要避免这种情况，尤其不同模块同名变量类型不同的话。**因此，减少全局符号的使用**<br>
若非要使用，解决方案：
<img src="markdown图片/屏幕截图 2023-11-21 172248.png" alt="图片alt" title="图片title"><br>
表明正在使用外部符号extern。<br>

## 2.重定位
1. 可重定位文件到可执行文件：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 181312.png" alt="图片alt" title="图片title"><br>
   注意，其中systemcode部分为lib.c，其从系统调用该程序开始到调用main。<br>
   可执行文件的text会把各个可重定位文件的text放在一起，data也放在一起。
   **重要的是补足其中的地址，见下**<br>
   
2. 可重定位文件细节：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 180621.png" alt="图片alt" title="图片title"><br>
   注意到，main.c中，array和sum都是全局符号，也就是单独编译时，编译器并不知道这两个符号的真正地址，所以以零值代替，并且给出提示要求链接器补足这些地址。<br>
   <img src="markdown图片/屏幕截图 2023-11-21 200544.png" alt="图片alt" title="图片title"><br>
   如上图所示，链接器浏览每个编译器的提示，然后根据链接器排列好的地址，把编译器未补足的地址补足。<br>


### ELF文件格式细节以及其被加载到内存后的内存细节：
<img src="markdown图片/屏幕截图 2023-11-21 202114.png" alt="图片alt" title="图片title"><br>
1. 可执行文件中，ro代码段和数据段才会被加载进内存中，用于调试部分从符号表symtab到strtab的不会。
2. 注意栈堆的位置。

## 库
把一大堆.o文件集合成一个.a文件，然后链接时只复制其中的需要的部分到总的可执行文件中。这样避免每次链接过多的.o文件，也避免链接一个大文件中不需要的其他函数。这就是库技术。<br>

### 静态库：
静态库的构建：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213033.png" alt="图片alt" title="图片title"><br>
使用：<br>

编译：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213916.png" alt="图片alt" title="图片title"><br>
注意，上述编译过程，在命令行中需要按顺序，也就是含有未定义的符号的文件需要在前面输入。
**注意要点**：
静态库链接与.o链接最大不同在于，与.a的静态库链接时，每一个.o程序与其链接，都会复制其中所需的程序的副本。换句话说是每个程序单独复制了，也单独进行的重定位。
<img src="markdown图片/屏幕截图 2023-11-21 222631.png" alt="图片alt" title="图片title"><br>
核心点在于：<br>
链接的颗粒度：直接链接单个目标文件时，链接器可以在所有提供的目标文件中进行符号解析，因此不会重复包含相同的函数。而使用静态库时，每个程序的链接过程是独立的，静态库中的函数会被重复包含在每个使用它的程序中。<br>
程序数量：在直接链接目标文件的例子中，所有的目标文件链接成一个单一的可执行文件。而在使用静态库的例子中，假设有三个独立的程序，每个都链接了包含 func 的静态库，因此每个程序都有自己的 func 副本。<br>

### 动态库
上述静态库问题在于与静态库的链接会在每一个程序和库之间单独进行，这就造成了大量的重复复制。<br>
1. 动态库（共享库）可以让可执行文件无需复制多个相同的代码段
2. 动态库可以让程序对库文件的调用在程序被加载（load time）进内存时复制，甚至可以在程序在内存中运行时(run time)复制。
3. 共享库可以被多个进程共享<br>
工作原理:
<img src="markdown图片/屏幕截图 2023-11-22 112134.png" alt="图片alt" title="图片title"><br>
如图，动态链接会在符号表中记录下对库中函数的引用，但是与静态库不同，它只是记下引用，是个部分链接，不会真的复制进去。函数的真正复制在程序运行时进行。<br>

库打桩技术：<br>


# 异常控制流
## 异常和进程
软件层面的异常控制，主要条件跳转，程序调用和返回等。<br>
操作系统层面的控制流跳转：硬件异常，进程切换，非正常函数跳转等<br>
### 异常
异常，是指将低级别的控制权转换回内核，什么是内核？<br>
**内核，指的是在内存中始终预留的操作系统的相关程序**<br>
<img src="markdown图片/屏幕截图 2023-11-22 154817.png" alt="图片alt" title="图片title"><br>
上图显示了异常调用，从用户态转为内核态，并在内核态的异常处理程序结束后，有如图的三种返回方式,返回目前程序指针，或者下一程序指针，或者abort终止。<br>

### 异常的类型与实现：
1. 硬件软件分类<br>
处理器异常：除0，内存访问违例，溢出，断点等；<br>
操作系统异常：系统调用,IO等<br>
**异常跳转**：<br>
运行时，处理器检测发生事件->确定异常号->触发异常->跳转异常表，再跳转表中地址。<br>
**异常跳转与过程调用的区别：**<br>
<img src="markdown图片/屏幕截图 2023-11-22 161029.png" alt="图片alt" title="图片title"><br>
2. 同步异步<br>
   A.异步异常（中断）：处理器，程序外部发生了状态变化引起的，通过中断引脚告知处理器。例如，从磁盘拷贝到内存中，拷贝完成，向中断引脚发送一条信息（IO中断）。  
   B. 同步异常：  
   一、 trap陷阱异常，程序为达成某目的故意引起的异常：<br>
   例如：**系统调用syscall**，调试断点，特殊指令等。  
   系统调用，内核代码能提供各种程序本身没有权限执行的服务，例如调用内核中的函数，以此发出对各种服务的请求。<br>
   **这个异常返回程序的下一个指令**<br>
   二、fault故障异常，**可能可以**被修复的错误：<br>
   例如：页缺失，即程序访问的内存段未在内存中，需要从磁盘拷入,这是可以修复的。保护故障，例如访问未被分配的内存段，这个不可被修复。<br>
   三、aborts中止异常，无意且不可恢复的异常：<br>
   一些非法的指令。**这个异常不会返回程序。**

### 详细介绍：
1. 以write函数为例介绍系统调用中的打开文件：<br>
   syscall函数，直接进行系统调用的函数，接收系统调用参数作为参数，但是一般不直接用它，使用包装后的系统函数<br>
   系统调用函数，**通过寄存器传递值，不通过栈**。rax为系统调用编号，6参数寄存器依然作为参数传递。  
   系统函数：包装了上述syscall函数。  
   以write来写printf：
   <img src="markdown图片/屏幕截图 2023-11-22 173733.png" alt="图片alt" title="图片title"><br>
   将write的系统调用id1放入rax中，其余参数放图rdi，rsi，rdx等中，然后执行syscall。<br>
2. fault,以页缺失为例。
   访问一个地址，有可能该地址还未在内存中，这时候调用系统页缺失程序，然后返回该访问指令<br>
   也有可能该地址是虚拟地址空间中的无效区域，因此这时候为无法修复的错误，此时他会向进程发送信号SIGSEGV，进程会返回段错误<br>
   例如下面的情况：<br>
   <img src="markdown图片/屏幕截图 2023-11-22 175856.png" alt="图片alt" title="图片title"><br>


# 进程
正在运行的程序的实例，系统中的每个程序都运行在每个进程的上下文中。<br>
上下文，由程序运行的状态构成，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量，以及打开文件描述符等的集合<br>

**进程提供以下两个抽象：**
1. 看起来独占逻辑控制流，独占CPU上的寄存器。
2. 看起来独占内存地址空间(虚拟内存机制)<br>
上面提供的两个抽象，让你在一个程序运行时，不用担心你的各种数值被修改，你的寄存器值是独一无二的,你的内存地址也是独一无二的。<br>

## 几个基本概念：
1. **并发**：
   两个逻辑流的执行在时间上重叠，即称为并发流，称这两个流并发的运行。<br>
   **与并行的区别：**<br>
   注意，并发只是逻辑流的概念，只要两个流在时间上有重叠就是并发的，即使它们运行在同一处理器上。那么，什么是并行：只要两个并发的逻辑流实现在不同的核或者不同的计算机上面，那就是两个并行的执行的并发流。<br>
   **时间节省**：<br>
   一般来说，能并行执行的并发逻辑流都是能省时间的，而由于要进行上下文切换，如果只在单核上，大多数情况会导致性能的下降，但并非都会下降，也要具体情况具体分析。<br>
   例如某些任务，一个逻辑流需要长时间计算，另一个逻辑流需要持续待机回应响应，这时候的进程切换就会有节省时间的作用。<br>
   或者某进程从磁盘read，等待read完成的过程中就可以切换到另一进程，**注意这样做能实现的原因是磁盘到内存无需CPU**<br>
2. **私有地址空间**：
   每个进程独有一段自己的私有地址空间，和该空间相关联（**这个地方换句话说，私有地址空间并非直接是物理内存地址**）的内存地址是不能被其他内存读和写的。
   
3. **用户模式和内核模式**：
   为了实现对进程的抽象，处理器必须提供一个标识，让它能够标注一个应用可以执行的指令和它可以访问的地址范围。<br>
   因此，处理器中有一个模式位，标识了当前的权限。用户模式下，程序不能执行某些指令，例如停止CPU，改变模式位，或者发起一个IO操作；不能读取某些地址，例如内核空间的地址。<br>
   一个应用程序，一开始总是从用户模式开始，而且只能通过异常，将模式转为内核模式。<br>
   **因此，实际上内存中只有一个内核模式空间，其余内存段为多个用户模式（多个进程）**<br>
   可参见下图的解析：<br>
   <img src="markdown图片/屏幕截图 2023-11-27 152537.png" alt="图片alt" title="图片title"><br>
   <img src="markdown图片/屏幕截图 2023-11-27 152636.png" alt="图片alt" title="图片title"><br>

## 多进程切换样例（上下文切换）：
上下文：内核重新启动一个被强占的进程，所需的状态。即该进程的某些对象，包括**寄存器值**，程序计数器，**堆栈指针**；描述地址空间的页表，当前进程信息的进程表等。<br>
调度：在当前进程运行的某个时刻，内核可以决定暂停当前进程，并重新开始一个之前被抢占了的进程，这就是调度。调度具体实现是由**上下文切换**实现<br>
上下文切换分为下面三步：<br>
1. 保存当前进程的上下文，**保存进位于内核空间的进程控制块中**
2. 恢复之前被抢占进程的上下文
3. 将控制传递给恢复的进程<br>
注意，上下文不用保存进程在内存中的东西，进程不结束这些东西都在内存中保留。<br>
引发上下文切换的方式有很多，例如**系统调用**，系统调用后某进程因为等待而阻塞；或者定时器终端等。<br>

# 进程控制：
从C程序中进行系统调用的系统级C函数（对syscall的包装）。
1. fork:<br>
   int fork(void)<br>
   原始fork，开启该进程的子进程，并返回开启的子进程的id，返回-1代表失败。<br>
   另外，由于对于系统调用级别函数，如果失败一般要让当前进程停止(exit),因此一般可用一个函数包装fork，返回-1时报错并退出。<br>
2. getpid,getppid 
3. 进程的三种运行态：  
   running:运行或**未运行但是可以被调度**  
   stopped：进程被挂起，**且不会被调度**，受信号控制，**信号是软件中断的一种形式**  
   terminated:终止，进程永远的终止了。有三个原因终止：1）.收到某个信号，它的默认行为是终止进程；2）.从主程序返回；3）.调用exit函数。

一、创建进程，fork函数详解：<br>
   **子进程创建后，复制父进程的整个内存，包括代码和数据，堆栈，程序计数器，共享库，文件描述符等，但注意，它是一个全新的进程，与父进程隔离，且拥有不同的pid**<br>
   **因此，实际上在一个程序中执行多个进程，就是使用pid来区分**，例如下述程序：<br>
   <img src="markdown图片/屏幕截图 2023-11-23 215333.png" alt="图片alt" title="图片title"><br>
   上述程序的几点：<br>
   1. 调用一次，返回两次，注意返回两次指的是父进程和子进程的分别返回，在父进程它返回子进程的pid，子进程返回0，因此，我们上图的程序才能通过**pid == 0的方式识别是哪个进程，因为程序都是一样的**。
   2. 相同但独立的地址空间：fork执行时，子进程将有父进程的一切并且相同，但是这之后就是独立的了，所以两个x在输出时是不同的。
   3. 共享文件，它们都将输出打印在标准输出上了。
   4. 进程图：
   利用进程图+**拓扑排序**的思想来分析多进程代码。<br>
   **特别注意，图顺序只有说a->b的情况下，b一定不能在a之前发生，但是如果没有节点之间的边，则不能判断进程的先后性，如下图：<br>
   <img src="markdown图片/屏幕截图 2023-11-24 112845.png" alt="图片alt" title="图片title"><br>
   注意，**进程发生先后顺序并非是层序遍历**，即在一个节点之后的所有节点，**（那些没有先后关系的，进程执行的顺序是不定的）**。<br>

二、 终止进程，僵尸进程状态：<br>
子进程终止->进入**僵尸进程态**(ps查看的defunct标识)->父进程回收（reap），内核将子进程的退出状态传递给父进程->彻底抛弃已终止的进程。<br>
对于父进程提前终止，尚未回收的子进程，称为孤儿进程，这些进程的退出状态保存在内核空间中，有占用。因此系统让id = 1的init进程负责回收。<br>

三、**使用waitpid处理终止进程的状态，以及控制进程先后性。**<br>
**如果父进程不使用waitpid处理子进程，那么子进程就是僵尸状态进程（defunct），如果父进程提前终止了，那么僵尸子进程就会被init进程回收**<br>
我们知道，子进程被创建后，
wait函数介绍：int wait(int *child_status)<br>
waitpid函数：pid_t waitpid(_pid_t pid, int *statusp,int options):<br>
解析：<br>
waitpid函数执行后，会挂起当前的进程的执行，直到它的等待集合（wait set）中的**一个**子进程终止或停止，如果等待集合中只要有一个进程在waitpid调用时就是终止的，则会立即返回。  
1. 返回：在上述两种情况中，会返回等待集合中的那个终止的子进程的pid。如果被调用进程没有子进程，或被一个信号中断，返回-1。
2. pid：pid == -1,则等待集合为该进程的所有子进程，pid>0,则等待集合为该pid的进程。
3. option，可以通过修改该值来调整waitpid的行为，细节见课本。
4. statusp：传入该指针，然后waitpid会在该指针指向的位置（要求非空）存放waitset中导致返回的哪一个子进程的状态信息。
wait函数是waitpid的简化版，int wait(&status) == _pid_t waitpid(-1,&status,0)  
<img src="markdown图片/屏幕截图 2023-11-24 154454.png" alt="图片alt" title="图片title"><br>
此时，进程图就变为了彻底需要拓扑排序来判断执行顺序的情况了，如上图所示。<br>

三、暂停与休眠：<br>
sleep(秒数)，pause；sleep会被信号提前打断，pause只有被信号打断才会继续进行。  

四、加载运行其他程序：<br>
execve,启动一个新的程序的进程：<br>
int execve(const char \*filename,const char \*argv[],const char \*envp[])  
execve提供可执行文件的文件名，以及该文件需要的参数argv和envp(**他们为一个指针数组，每个指针指向一个char\*，也就是字符串,如1中图所示**)，该函数除非调用失败会返回，否则**从不返回**。

**execve的调用一次且不返回，是指使用execve的当前进程，其所占的内存空间整个的都会被新调用的程序所占用，也就是当前进程整个的切换为新调用的程序了(不是开一个新进程)**<br>
**execve 系统调用用于在当前进程的上下文中执行一个新程序。当 execve 被调用时，它会加载新程序的代码和数据，替换当前进程的代码和数据，而当前进程的执行则结束。这就是为什么说 execve 调用一次且不返回（除非有错误发生）。**<br>
1. 上述上下文执行新程序的保留内容和替换内容：  
   <img src="markdown图片/屏幕截图 2023-11-24 173808.png" alt="图片alt" title="图片title"><br>
   上图1中的，代码数据段，堆栈等都是在内存用户区，而pid，文件描述符这些都在内存内核区域中。<br>
2. 启动新程序的传参和main函数解析<br>
   具体来说，execve执行了filename的程序后，其调用启动代码，然后将控制传递给新程序的main，如下所示：  
   int main(int argc,int **argv,char ** envp) 
   <img src="markdown图片/屏幕截图 2023-11-24 170329.png" alt="图片alt" title="图片title"><br>
   系统将这些的结构覆盖进程的上下文，然后将控制权交换到用户态的main函数位置。<br>
   <img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
   argv，envp都是传给新程序的参数，但其有区别：<br>
   argv:使程序能够接收用户输入的参数，这对于指导程序的运行行为非常重要<br>
   envp：提供了一种机制，通过它，操作系统和运行环境可以传递配置信息给程序，无需改变程序代码。环境变量对于配置程序行为、设定资源路径和控制程序运行的环境非常有用。<br>
   
3. fork+execve的组合使用：<br>
   由于execve执行后就不再返回，相当于当前进程就这么结束了,后面的代码都无效了，因此一般用fork开一个子进程来执行加载别的程序<br>

# 信号
几个概念：<br>
1. 外部事件，异步事件：  
   上述两种都指的进程控制流之外的事件。但是强调的点不同:
   <img src="markdown图片/屏幕截图 2023-11-26 163959.png" alt="图片alt" title="图片title"><br>
2. 同步事件：<br>
   <img src="markdown图片/屏幕截图 2023-11-26 164511.png" alt="图片alt" title="图片title"><br>

## shell，linux进程架构：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
shell命令的实现：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
执行eval函数计算表达式：<br>

eval函数解析：<br>


## 信号概念以及实现方式：
**信号概念**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 163355.png" alt="图片alt" title="图片title"><br>
信号实现方式：**内核给目标进程发送或传递一个信号，通过为目标进程的上下文设置一些状态来实现.**<br>
注：信号对于接收的程序来说，是一种异步的行为。<br>

**进程接收到信号的处理方式**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 160300.png" alt="图片alt" title="图片title"><br>
如图所示，进程接收到信号后，进程的某些上下文状态会改变，此时进程会有三种回应该信号的方式：<br>
1. 忽视该信号
2. 终止进程
3. catch，进入信号处理程序。这里类似中断，但是**异常处理程序都在内核态中，而信号处理程序都是C代码，位于用户态**

**信号特点**：<br>
1. 某一进程，对某一类信号而言，随时只能有一个待处理信号。<br>
   原因以及原理如下:<br>
   <img src="markdown图片/屏幕截图 2023-11-26 173139.png" alt="图片alt" title="图片title"><br>
   可以看到，某一类型信号只有一位进行标识，因此某一进程中随时只有一个类型为k的待处理信号。

## 发送信号细节：
1. 命令行kill程序发送信号：

<img src="markdown图片/屏幕截图 2023-11-26 175151.png" alt="图片alt" title="图片title"><br>
**其中的kill：实际kill本意是发送信号给某进程的程序，第一个参数为发送的信号的表示，第二个参数为进程组或者进程**

2. Ctrlc，ctrlz：
   c终止，z挂起（都是向前台进程组发送的信号）。
<img src="markdown图片/屏幕截图 2023-11-26 180206.png" alt="图片alt" title="图片title"><br>

3. shell
4. kill函数
5. alarm函数  
   上述函数细节可参看课本。  

## 接收信号
每当程序由内核态转为某进程P的用户态时，它都会先检查该进程的待处理信号集合，即信号接收标识pending和阻塞标识blocking：**（pending & ~blocking）**。之后，会有下列两种情况：<br>
1. 集合为空，则执行p的程序计数器指针位置（即Inext）
2. 集合非空，内核强制选择集合中某个信号（一般是最小的那个k），该进程会进行接收信号行为。一旦进程完成了该行为而不终止，则完成该行为后会执行Inext。
   
### 接收信号行为：
1. 各种信号都有默认行为，例如终止，停止，忽略等
2. 修改的行为，程序可以自己写signal函数修改默认信号处理行为。可见代码signal对ctrlc的修改：<br>
<img src="markdown图片/屏幕截图 2023-11-27 163807.png" alt="图片alt" title="图片title"><br>
如图所示，signal可对第一个参数所标识的信号的默认行为进行修改，将其修改为第二个参数指向的函数(假设为sigfuc)。sighandler_t类型意思为void类型返回的函数指针，其函数参数为int。<br>
因此signal函数执行时，将该函数编号传递给信号处理函数sigfuc，然后信号处理函数进行处理。对于signal函数来说，信号处理成果则返回sigfuc的指针，若调用失败则返回SIG_ERR。
3. 信号处理函数可以被其他信号处理函数中断，**正如信号处理函数依然是用户态函数一样，其他信号处理函数结束后依然会回到该信号处理函数**：  
   这依然是一种异步行为，即你没办法定义信号处理函数什么时候会被接收到别的信号去中断它，除非你pause挂起了。
4. 另外，信号的处理是由系统管理的，也就是你处理程序的跳转**是直接调转到signal函数的第二个参数的指定的位置的**，然后执行结果返回哪一个位置也是系统管理的。

### 信号是并发的一种形式
这种是在同一进程内部的并发工作流，会带来很多问题：<br>
<img src="markdown图片/屏幕截图 2023-11-27 201125.png" alt="图片alt" title="图片title"><br>

### 阻塞
默认阻塞：某类信号处理程序在执行时，会默认阻塞相同的信号类型  
用户态控制：
sigprocmask等函数，**用于防止关键代码段执行时被异步信号打断，可用于实现原子操作**



   
### 信号处理程序的三个要点：
1. 并发性，因此对某些数据的修改要注意安全和一致性
<img src="markdown图片/屏幕截图 2023-11-27 203353.png" alt="图片alt" title="图片title"><br>
printf就不是一个异步信号安全的函数，因为printf会给终端上锁，而printf本身会中断，如果printf执行过程中进入内核态，此时又有信号过来，该信号处理程序中也有printf的话，就会死锁了。  
详情见课本：<br>
2. 无队列性，某个类型的信号是始终只有一个的，不排队。因此你不能利用信号处理程序统计有多少个信号到达过该进程。<br>
见sigchild.c代码，sigchild信号为子进程终止或者停止时发送给父进程的信号，然鹅，不能使用信号处理程序统计某一进程收到了多少信号。详见代码sigchild.c<br>
上述子进程信号程序引发一个思考就是，如何利用SIGCHILD信号检测子进程的终止或停止：<br>
需要用waitpid来在一个信号到达时处理所有等待的子进程<br>

### 信号处理函数与并行流
信号处理函数天然是一个并行流，因此需要考虑的东西就变多了。<br>

### 进程如何显式的等待信号来运行：
例如进程需要子进程结束的信息来进一步运行，可以见函数waitchild.c:<br>
<img src="markdown图片/屏幕截图 2023-11-28 204616.png" alt="图片alt" title="图片title"><br>
在sigchild的信号处理程序中，设置全局的pid！=0，然后主进程中的while即可结束循环。<br>
**上面的方法是对的，但是while过程执行的太久，占有时间长**  
下列修复方法：<br>
<img src="markdown图片/屏幕截图 2023-11-28 205102.png" alt="图片alt" title="图片title"><br>
左边的方法实际上会有问题，加入sigchild信号在while和pause之间到达，那么就永远不会解决pause了。右边的方法又太慢了。<br>
因此，可以想到解决方案为在左边的pause处加入信号阻塞，**在pause执行时接受sigchil,执行后又不能接受sigchil了，并且一定要保证这几步在一起进行，否则依然会出现开启接收sigchild然后马上就有信号的问题**，听起来是一个不可能实现的操作，但实际上可以用原子操作实现，如下所示：<br>
<img src="markdown图片/屏幕截图 2023-11-28 210144.png" alt="图片alt" title="图片title"><br>
即上图的三个指令是一起执行的，不可被中断，**关掉对sigchild的阻塞，暂停，开启对sigchild的阻塞**这里面前两步是一起进行的。
注意这里面第三步也是有意义的。

### 可重入函数，异步信号安全函数



# 虚拟内存
对物理内存的抽象（增加了映射（哈希））<br>
为什么要用虚拟内存：<br>
1. 简化内存管理，每个进程可以给出相同的地址空间分布
2. 隔离地址空间，每个进程实际上在内存中又是隔离的
3. 可以作为某种缓存

# 几个概念：<br>
页：大小一般为4kb，VM的基本单位，其具体的映射关系由页表管理。   
页表：PT，其由一个个页表条目（PTE）构成，每个进程都有一个，表明该进程的虚拟内存与真实物理内存的映射关系。**注意页表PTE本身也保存在内存中**<br>
页表条目：由一个有效位加n位地址构成，其中，n为地址又可以被分为p为的偏移量和n-p位的虚拟页号。这个虚拟页号就是哈希的键，值为对应的物理内存地址或者磁盘地址，其有n-p位。剩下p位则表示在该页中的偏移，如果页的大小为4096个字节，那么p = log2(4096) = 12。

**下面是详细介绍**

## VM as a tool for caching
VM从概念上，是磁盘上的N个连续的字节大小的单元所构成的数组。具体的说，虚拟内存作为硬盘的缓存的含义如下：<br>
<img src="markdown图片/屏幕截图 2023-11-29 170953.png" alt="图片alt" title="图片title"><br>

**实际上，这也算是利用了局部性，利用了一个程序的整体局部性，一个程序的工作集假如全部被拷进内存，那么其读写速度要快的多**  

**另外，一个页表是包含一块数据和偏移量的，因此程序即使读了一小部分，也会把那块整个的从硬盘搬到内存中，这一点依然可以利用局部性的，详细见地址翻译**

当然，实际上由于硬盘也是按块加载进入内存的，所以实际内存存的也会比所需的要多。严格来说这是利用了内存读取硬盘和其他指令的并行来加速的。<br>
<img src="markdown图片/屏幕截图 2023-11-29 171237.png" alt="图片alt" title="图片title"><br>
VM与内存的映射结构如上图。

**因此，内存作为硬盘的缓存，其主要的代价来源于未命中的从而需要从硬盘重新拷贝的时间**<br>
注：也因为硬盘与缓存之间的巨大开销，所以内存总是使用写回策略。

细节介绍：<br>
1. 虚拟内存，物理内存，磁盘的映射关系：
<img src="markdown图片/屏幕截图 2023-11-29 180546.png" alt="图片alt" title="图片title"><br>
如图，每一个基本单元都是虚拟内存的页表大小。我们可以得出下面几点：<br>
A、**每个进程都有自己的虚拟内存，然后该虚拟内存的映射表放在进程的用户态中**<br>
B、图中可以看到虚拟内存页表PT与页表条目（PTE），PTE由有效位和地址构成，图中可以看到它的三种情况：一是有效位为1的，虚拟内存映射到物理内存，即当前访问的磁盘数据在相应地址的物理内存存在。剩下的是有效位为0，一种情况为有地址，则该地址为磁盘地址，即未缓存状态，最后是无地址的（null），即未建立任何映射的未分配状态。

2. 寻找相应内存  
page hit:<br>
<img src="markdown图片/屏幕截图 2023-11-29 205720.png" alt="图片alt" title="图片title"><br>
handler page fault:<br>
<img src="markdown图片/屏幕截图 2023-11-29 194545.png" alt="图片alt" title="图片title"><br>
当寻找的数据不在物理内存而在磁盘中，（如图中的PTE3），即相应的虚拟内存地址的valid为0时，触发以下步骤：<br>
A、触发缺页异常，用户态跳入内核态的缺页处理函数  
B、如果此时内存已经满了，那么缺页处理函数检查缓存策略算法，其给出需要驱逐物理内存中的哪一块（这也意味着映射到该块的虚拟内存PTE要被改变），假设打算驱逐PTE4和对应的VP4  
C、驱逐那一块VP4，并执行写回策略,同时PTE4改成相应的磁盘地址    
D、将寻找的数据放入物理内存中，然后更新页表PTE3，PTE3改成内存地址    
E、最后回到发生中断的那个指令上，这就不会再发生缺页异常了，然后是执行page hit步骤了  
<img src="markdown图片/屏幕截图 2023-11-29 205624.png" alt="图片alt" title="图片title"><br>

allocate page:<br>
假如此时VM中有页未被分配指向任何数据（磁盘或者内存），那它就是未分配的，即malloc调用sbrk函数给这些页分配指向，实际上是给他们的PTE增加了指向磁盘的地址。**只有在访问需要这个磁盘地址的数据时，系统才把磁盘里面的数据拷到内存中**

## VM是一个内存管理工具
VM的增加一层抽象的思想，极大的方便了内存的处理，让每一个进程都能有自己的一个虚拟内存空间。<br>
<img src="markdown图片/屏幕截图 2023-11-29 202638.png" alt="图片alt" title="图片title"><br>
1、如果每一个进程都要在整个内存中分配自己的空间，这将带来无数的问题。而如果将内存划分成小块提供给进程，这又有一大堆问题，例如进程扩容怎么办，进程销毁是不是带来内存浪费，所以说这还不如用个哈希表包装一层<br>
2、另外，链接时，如果要在整个内存中来做，你无法预先知道进程会在那个地址，因此就无法链接<br>

## VM是一个权限管理工具
<img src="markdown图片/屏幕截图 2023-11-29 204105.png" alt="图片alt" title="图片title"><br>

## 地址翻译
1. 翻译的细节  
<img src="markdown图片/屏幕截图 2023-11-29 205321.png" alt="图片alt" title="图片title"><br>
2. 加入缓存的考量  
由于PTE在内存中，所以如果能把最近使用的页表数据也放到缓存中，无疑又进一步优化了时间。 

### 多级页表
现在，分析一下页表的大小，由于页表需要对地址空间每一个位做一一映射，因此，由于地址空间有48，2^48字节，然后页的大小为4kb，2^12字节，因此首先要分清页，这就需要2^36了，然后每一个页的页表数据又是8字节，2^3的来表示,因此总共需要2^39字节的大小的来存储页表，这是512GB，太大了。