# 链接

静态链接：<br>
<img src="markdown图片/屏幕截图 2023-11-20 210611.png" alt="图片alt" title="图片title"><br>

## 链接器(linker)做了什么：
1. 符号解析<br>
   <img src="markdown图片/屏幕截图 2023-11-20 213510.png" alt="图片alt" title="图片title"><br>
   将各个文件的符号（**全局变量与函数和静态变量**）和他们的引用以结构形式存储在符号表中。<br>
   问题：<br>
   假如不同文件有不同的符号定义，linker需要确定哪一个是用于后续引用的。<br>
2. 重定位
   <img src="markdown图片/屏幕截图 2023-11-20 214643.png" alt="图片alt" title="图片title"><br>
   单一目标的汇编文件中，程序中的各个函数，数据地址只是在该模块中的偏移量，由于地址随机化的原因，不能给出某个模块的绝对地址，因此，重定位的目的是将每个符号定义与每个内存位置关联起来，然后修改符号定义的所有引用，使其指向这些位置。<br>
3. 文件介绍：
   <img src="markdown图片/屏幕截图 2023-11-20 215501.png" alt="图片alt" title="图片title"><br>
   可重定位目标.o文件（二进制文件），链接器链接后产生的可执行文件.out，可共享库文件.so。<br>

## 细节：
   上述几个文件的细节：<br>
1. 可重定位目标文件：由各个字节块组成，指令在一个字节块中，初始化的全局变量在另一块字节序列中，未初始化的又在另外一块中。即单个文件编译后的不同块中，有的包含指令，有的包含目标数据。
2. 可执行目标文件：链接器产生的文件，可以直接被复制到内存中执行。
3. 共享目标文件：一种特殊类型的可重定位目标文件，可在加载和运行时被动态的加载进内存并链接。

### ELF文件格式：
**ELF，可执行，可链接文件的字节序列格式。**<br>
<img src="markdown图片/屏幕截图 2023-11-21 111026.png" alt="图片alt" title="图片title"><br>
补充说明：
1. segment header table（可执行文件必须有）：提供了下列各节的地址和大小，指出了代码不同段在内存中的位置。

下一部分，符号表部分：<br>
<img src="markdown图片/屏幕截图 2023-11-21 113613.png" alt="图片alt" title="图片title"><br>

### 符号
解析前面说的符号:<br>
<img src="markdown图片/屏幕截图 2023-11-21 152454.png" alt="图片alt" title="图片title"><br>
补充说明：<br>
链接器主要负责一下三种符号,**注意局部栈变量由编译器管理，利用栈解决，不属于链接器管理，也因此不在符号表中** <br>
会在符号表中的符号：<br>
1. global symbols：全局符号<br>
   **指在该模块中，定义的可被各模块都可使用的全局函数或变量**。因此，在单一模块编译时，即使某个符号未定义，编译器也不会报错，会认为是在其他模块具体定义的。

2. external symbols：外部符号<br>
   **指该模块引用了，但是在别的模块定义的符号**
3. local symbols：本地符号<br>
   指加了static的**全局**变量和函数，这就是static的作用，这使得该全局变量只能在本模块使用，不能链接到其他模块。<br>
4. 补充，static修饰的局部变量，也会在符号表中：它实际上是一个全局变量，被存在data或bss中（根据初始化与否），但是作用域有只在局部的变量。<br>

## 1.符号解析流程
1. 首先解析符号属性
2. 解析符号强弱，未初始化的变量被认为是弱的，函数和初始化的变量被认为是强的。**因此，多种同名符号，链接器会选择一个强符号，然后其他的弱符号链接到它上面，作为它的引用；所以只能有一个同名的强符号，有多个会报错。**<br>
另外，由多个同名弱符号无强符号的情况，链接器会随机选择一个作为定义，这明显会出现问题，尤其不同模块相同名称类型不同的情况（详见符号表结构）；因此在gcc加入no-common来报错避免该情况。但总的来说，要避免这种情况，尤其不同模块同名变量类型不同的话。**因此，减少全局符号的使用**<br>
若非要使用，解决方案：
<img src="markdown图片/屏幕截图 2023-11-21 172248.png" alt="图片alt" title="图片title"><br>
表明正在使用外部符号extern。<br>

## 2.重定位
1. 可重定位文件到可执行文件：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 181312.png" alt="图片alt" title="图片title"><br>
   注意，其中systemcode部分为lib.c，其从系统调用该程序开始到调用main。<br>
   可执行文件的text会把各个可重定位文件的text放在一起，data也放在一起。
   **重要的是补足其中的地址，见下**<br>
   
2. 可重定位文件细节：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 180621.png" alt="图片alt" title="图片title"><br>
   注意到，main.c中，array和sum都是全局符号，也就是单独编译时，编译器并不知道这两个符号的真正地址，所以以零值代替，并且给出提示要求链接器补足这些地址。<br>
   <img src="markdown图片/屏幕截图 2023-11-21 200544.png" alt="图片alt" title="图片title"><br>
   如上图所示，链接器浏览每个编译器的提示，然后根据链接器排列好的地址，把编译器未补足的地址补足。<br>


### ELF文件格式细节以及其被加载到内存后的内存细节：
<img src="markdown图片/屏幕截图 2023-11-21 202114.png" alt="图片alt" title="图片title"><br>
1. 可执行文件中，ro代码段和数据段才会被加载进内存中，用于调试部分从符号表symtab到strtab的不会。
2. 注意栈堆的位置。

## 库
把一大堆.o文件集合成一个.a文件，然后链接时只复制其中的需要的部分到总的可执行文件中。这样避免每次链接过多的.o文件，也避免链接一个大文件中不需要的其他函数。这就是库技术。<br>

### 静态库：
静态库的构建：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213033.png" alt="图片alt" title="图片title"><br>
使用：<br>

编译：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213916.png" alt="图片alt" title="图片title"><br>
注意，上述编译过程，在命令行中需要按顺序，也就是含有未定义的符号的文件需要在前面输入。
**注意要点**：
静态库链接与.o链接最大不同在于，与.a的静态库链接时，每一个.o程序与其链接，都会复制其中所需的程序的副本。换句话说是每个程序单独复制了，也单独进行的重定位。
<img src="markdown图片/屏幕截图 2023-11-21 222631.png" alt="图片alt" title="图片title"><br>
核心点在于：<br>
链接的颗粒度：直接链接单个目标文件时，链接器可以在所有提供的目标文件中进行符号解析，因此不会重复包含相同的函数。而使用静态库时，每个程序的链接过程是独立的，静态库中的函数会被重复包含在每个使用它的程序中。<br>
程序数量：在直接链接目标文件的例子中，所有的目标文件链接成一个单一的可执行文件。而在使用静态库的例子中，假设有三个独立的程序，每个都链接了包含 func 的静态库，因此每个程序都有自己的 func 副本。<br>

### 动态库
上述静态库问题在于与静态库的链接会在每一个程序和库之间单独进行，这就造成了大量的重复复制。<br>
1. 动态库（共享库）可以让可执行文件无需复制多个相同的代码段
2. 动态库可以让程序对库文件的调用在程序被加载（load time）进内存时复制，甚至可以在程序在内存中运行时(run time)复制。
3. 共享库可以被多个进程共享<br>
工作原理:
<img src="markdown图片/屏幕截图 2023-11-22 112134.png" alt="图片alt" title="图片title"><br>
如图，动态链接会在符号表中记录下对库中函数的引用，但是与静态库不同，它只是记下引用，是个部分链接，不会真的复制进去。函数的真正复制在程序运行时进行。<br>

库打桩技术：<br>


# 异常控制流
## 异常和进程
软件层面的异常控制，主要条件跳转，程序调用和返回等。<br>
操作系统层面的控制流跳转：硬件异常，进程切换，非正常函数跳转等<br>
### 异常
异常，是指将低级别的控制权转换回内核，什么是内核？<br>
**内核，指的是在内存中始终预留的操作系统的相关程序**<br>
<img src="markdown图片/屏幕截图 2023-11-22 154817.png" alt="图片alt" title="图片title"><br>
上图显示了异常调用，从用户态转为内核态，并在内核态的异常处理程序结束后，有如图的三种返回方式,返回目前程序指针，或者下一程序指针，或者abort终止。<br>

### 异常的类型与实现：
1. 硬件软件分类<br>
处理器异常：除0，内存访问违例，溢出，断点等；<br>
操作系统异常：系统调用,IO等<br>
**异常跳转**：<br>
运行时，处理器检测发生事件->确定异常号->触发异常->跳转异常表，再跳转表中地址。<br>
**异常跳转与过程调用的区别：**<br>
<img src="markdown图片/屏幕截图 2023-11-22 161029.png" alt="图片alt" title="图片title"><br>
2. 同步异步<br>
   A.异步异常（中断）：处理器，程序外部发生了状态变化引起的，通过中断引脚告知处理器。例如，从磁盘拷贝到内存中，拷贝完成，向中断引脚发送一条信息（IO中断）。  
   B. 同步异常：  
   一、 trap陷阱异常，程序为达成某目的故意引起的异常：<br>
   例如：**系统调用syscall**，调试断点，特殊指令等。  
   系统调用，内核代码能提供各种程序本身没有权限执行的服务，例如调用内核中的函数，以此发出对各种服务的请求。<br>
   **这个异常返回程序的下一个指令**<br>
   二、fault故障异常，**可能可以**被修复的错误：<br>
   例如：页缺失，即程序访问的内存段未在内存中，需要从磁盘拷入,这是可以修复的。保护故障，例如访问未被分配的内存段，这个不可被修复。<br>
   三、aborts中止异常，无意且不可恢复的异常：<br>
   一些非法的指令。**这个异常不会返回程序。**

### 详细介绍：
1. 以write函数为例介绍系统调用中的打开文件：<br>
   syscall函数，直接进行系统调用的函数，接收系统调用参数作为参数，但是一般不直接用它，使用包装后的系统函数<br>
   系统调用函数，**通过寄存器传递值，不通过栈**。rax为系统调用编号，6参数寄存器依然作为参数传递。  
   系统函数：包装了上述syscall函数。  
   以write来写printf：
   <img src="markdown图片/屏幕截图 2023-11-22 173733.png" alt="图片alt" title="图片title"><br>
   将write的系统调用id1放入rax中，其余参数放图rdi，rsi，rdx等中，然后执行syscall。<br>
2. fault,以页缺失为例。
   访问一个地址，有可能该地址还未在内存中，这时候调用系统页缺失程序，然后返回该访问指令<br>
   也有可能该地址是虚拟地址空间中的无效区域，因此这时候为无法修复的错误，此时他会向进程发送信号SIGSEGV，进程会返回段错误<br>
   例如下面的情况：<br>
   <img src="markdown图片/屏幕截图 2023-11-22 175856.png" alt="图片alt" title="图片title"><br>


# 进程
正在运行的程序的实例，系统中的每个程序都运行在每个进程的上下文中。<br>
上下文，由程序运行的状态构成，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量，以及打开文件描述符等的集合<br>

**进程提供以下两个抽象：**
1. 看起来独占逻辑控制流，独占CPU上的寄存器。
2. 看起来独占内存地址空间(虚拟内存机制)<br>
上面提供的两个抽象，让你在一个程序运行时，不用担心你的各种数值被修改，你的寄存器值是独一无二的,你的内存地址也是独一无二的。<br>

## 几个基本概念：
1. **并发**：
   两个逻辑流的执行在时间上重叠，即称为并发流，称这两个流并发的运行。<br>
   **与并行的区别：**<br>
   注意，并发只是逻辑流的概念，只要两个流在时间上有重叠就是并发的，即使它们运行在同一处理器上。那么，什么是并行：只要两个并发的逻辑流实现在不同的核或者不同的计算机上面，那就是两个并行的执行的并发流。<br>
   **时间节省**：<br>
   一般来说，能并行执行的并发逻辑流都是能省时间的，而由于要进行上下文切换，如果只在单核上，大多数情况会导致性能的下降，但并非都会下降，也要具体情况具体分析。<br>
   例如某些任务，一个逻辑流需要长时间计算，另一个逻辑流需要持续待机回应响应，这时候的进程切换就会有节省时间的作用。<br>
   或者某进程从磁盘read，等待read完成的过程中就可以切换到另一进程，**注意这样做能实现的原因是磁盘到内存无需CPU**<br>
2. **私有地址空间**：
   每个进程独有一段自己的私有地址空间，和该空间相关联（**这个地方换句话说，私有地址空间并非直接是物理内存地址**）的内存地址是不能被其他内存读和写的。
   
3. **用户模式和内核模式**：
   为了实现对进程的抽象，处理器必须提供一个标识，让它能够标注一个应用可以执行的指令和它可以访问的地址范围。<br>
   因此，处理器中有一个模式位，标识了当前的权限。用户模式下，程序不能执行某些指令，例如停止CPU，改变模式位，或者发起一个IO操作；不能读取某些地址，例如内核空间的地址。<br>
   一个应用程序，一开始总是从用户模式开始，而且只能通过异常，将模式转为内核模式。<br>

## 多进程切换样例（上下文切换）：
上下文：内核重新启动一个被强占的进程，所需的状态。即该进程的某些对象，包括**寄存器值**，程序计数器，**堆栈指针**；描述地址空间的页表，当前进程信息的进程表等。<br>
调度：在当前进程运行的某个时刻，内核可以决定暂停当前进程，并重新开始一个之前被抢占了的进程，这就是调度。调度具体实现是由**上下文切换**实现<br>
上下文切换分为下面三步：<br>
1. 保存当前进程的上下文，**保存进位于内核空间的进程控制块中**
2. 恢复之前被抢占进程的上下文
3. 将控制传递给恢复的进程<br>
注意，上下文不用保存进程在内存中的东西，进程不结束这些东西都在内存中保留。<br>
引发上下文切换的方式有很多，例如**系统调用**，系统调用后某进程因为等待而阻塞；或者定时器终端等。<br>

# 进程控制：
从C程序中进行系统调用的系统级C函数（对syscall的包装）。
1. fork:<br>
   int fork(void)<br>
   原始fork，开启该进程的子进程，并返回开启的子进程的id，返回-1代表失败。<br>
   另外，由于对于系统调用级别函数，如果失败一般要让当前进程停止(exit),因此一般可用一个函数包装fork，返回-1时报错并退出。<br>
2. getpid,getppid 
3. 进程的三种运行态：  
   running:运行或**未运行但是可以被调度**  
   stopped：进程被挂起，**且不会被调度**，受信号控制，**信号是软件中断的一种形式**  
   terminated:终止，进程永远的终止了。有三个原因终止：1）.收到某个信号，它的默认行为是终止进程；2）.从主程序返回；3）.调用exit函数。

一、创建进程，fork函数详解：<br>
   **子进程创建后，复制父进程的整个内存，包括代码和数据，堆栈，程序计数器，共享库，文件描述符等，但注意，它是一个全新的进程，与父进程隔离，且拥有不同的pid**<br>
   **因此，实际上在一个程序中执行多个进程，就是使用pid来区分**，例如下述程序：<br>
   <img src="markdown图片/屏幕截图 2023-11-23 215333.png" alt="图片alt" title="图片title"><br>
   上述程序的几点：<br>
   1. 调用一次，返回两次，注意返回两次指的是父进程和子进程的分别返回，在父进程它返回子进程的pid，子进程返回0，因此，我们上图的程序才能通过**pid == 0的方式识别是哪个进程，因为程序都是一样的**。
   2. 相同但独立的地址空间：fork执行时，子进程将有父进程的一切并且相同，但是这之后就是独立的了，所以两个x在输出时是不同的。
   3. 共享文件，它们都将输出打印在标准输出上了。
   4. 进程图：
   利用进程图+**拓扑排序**的思想来分析多进程代码。<br>
   **特别注意，图顺序只有说a->b的情况下，b一定不能在a之前发生，但是如果没有节点之间的边，则不能判断进程的先后性，如下图：<br>
   <img src="markdown图片/屏幕截图 2023-11-24 112845.png" alt="图片alt" title="图片title"><br>
   注意，**进程发生先后顺序并非是层序遍历**，即在一个节点之后的所有节点，**（那些没有先后关系的，进程执行的顺序是不定的）**。<br>

二、 终止进程，僵尸进程状态：<br>
子进程终止->进入**僵尸进程态**(ps查看的defunct标识)->父进程回收（reap），内核将子进程的退出状态传递给父进程->彻底抛弃已终止的进程。<br>
对于父进程提前终止，尚未回收的子进程，称为孤儿进程，这些进程的退出状态保存在内核空间中，有占用。因此系统让id = 1的init进程负责回收。<br>
三、使用wait函数控制进程先后性。<br>
我们知道，子进程被创建后，
wait函数介绍：int wait(int *child_status)<br>
waitpid函数：pid_t waitpid(_pid_t pid, int *statusp,int options):<br>
解析：<br>
waitpid函数执行后，会挂起当前的进程的执行，直到它的等待集合（wait set）中的**一个**子进程终止或停止，如果等待集合中只要有一个进程在waitpid调用时就是终止的，则会立即返回。  
1. 返回：在上述两种情况中，会返回等待集合中的那个终止的子进程的pid。如果被调用进程没有子进程，或被一个信号中断，返回-1。
2. pid：pid == -1,则等待集合为该进程的所有子进程，pid>0,则等待集合为该pid的进程。
3. option，可以通过修改该值来调整waitpid的行为，细节见课本。
4. statusp：传入该指针，然后waitpid会在该指针指向的位置（要求非空）存放waitset中导致返回的哪一个子进程的状态信息。
wait函数是waitpid的简化版，int wait(&status) == _pid_t waitpid(-1,&status,0)  
<img src="markdown图片/屏幕截图 2023-11-24 154454.png" alt="图片alt" title="图片title"><br>
此时，进程图就变为了彻底需要拓扑排序来判断执行顺序的情况了，如上图所示。<br>

三、暂停与休眠：<br>
sleep(秒数)，pause；sleep会被信号提前打断，pause只有被信号打断才会继续进行。  

四、加载运行其他程序：<br>
execve,启动一个新的程序的进程：<br>
int execve(const char \*filename,const char \*argv[],const char \*envp[])  
execve提供可执行文件的文件名，以及该文件需要的参数argv和envp(**他们为一个指针数组，每个指针指向一个char\*，也就是字符串,如1中图所示**)，该函数除非调用失败会返回，否则**从不返回**。

**execve的调用一次且不返回，是指使用execve的当前进程，其所占的内存空间整个的都会被新调用的程序所占用，也就是当前进程整个的切换为新调用的程序了(不是开一个新进程)**<br>
**execve 系统调用用于在当前进程的上下文中执行一个新程序。当 execve 被调用时，它会加载新程序的代码和数据，替换当前进程的代码和数据，而当前进程的执行则结束。这就是为什么说 execve 调用一次且不返回（除非有错误发生）。**<br>
1. 上述上下文执行新程序的保留内容和替换内容：  
   <img src="markdown图片/屏幕截图 2023-11-24 173808.png" alt="图片alt" title="图片title"><br>
   上图1中的，代码数据段，堆栈等都是在内存用户区，而pid，文件描述符这些都在内存内核区域中。<br>
2. 启动新程序的传参和main函数解析<br>
   具体来说，execve执行了filename的程序后，其调用启动代码，然后将控制传递给新程序的main，如下所示：  
   int main(int argc,int **argv,char ** envp) 
   <img src="markdown图片/屏幕截图 2023-11-24 170329.png" alt="图片alt" title="图片title"><br>
   系统将这些的结构覆盖进程的上下文，然后将控制权交换到用户态的main函数位置。<br>
   <img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
   argv，envp都是传给新程序的参数，但其有区别：<br>
   argv:使程序能够接收用户输入的参数，这对于指导程序的运行行为非常重要<br>
   envp：提供了一种机制，通过它，操作系统和运行环境可以传递配置信息给程序，无需改变程序代码。环境变量对于配置程序行为、设定资源路径和控制程序运行的环境非常有用。<br>
   
3. fork+execve的组合使用：<br>
   由于execve执行后就不再返回，相当于当前进程就这么结束了,后面的代码都无效了，因此一般用fork开一个子进程来执行加载别的程序<br>

# 信号
几个概念：<br>
1. 外部事件，异步事件：  
   上述两种都指的进程控制流之外的事件。但是强调的点不同:
   <img src="markdown图片/屏幕截图 2023-11-26 163959.png" alt="图片alt" title="图片title"><br>
2. 同步事件：<br>
   <img src="markdown图片/屏幕截图 2023-11-26 164511.png" alt="图片alt" title="图片title"><br>

## shell，linux进程架构：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
shell命令的实现：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
执行eval函数计算表达式：<br>

eval函数解析：<br>


## 信号概念以及实现方式：
**信号概念**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 163355.png" alt="图片alt" title="图片title"><br>
信号实现方式：**内核给目标进程发送或传递一个信号，通过为目标进程的上下文设置一些状态来实现.**<br>
注：信号对于接收的程序来说，是一种异步的行为。<br>

**进程接收到信号的处理方式**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 160300.png" alt="图片alt" title="图片title"><br>
如图所示，进程接收到信号后，进程的某些上下文状态会改变，此时进程会有三种回应该信号的方式：<br>
1. 忽视该信号
2. 终止进程
3. catch，进入信号处理程序。这里类似中断，但是**异常处理程序都在内核态中，而信号处理程序都是C代码，位于用户态**

**信号特点**：<br>
1. 某一进程，对某一类信号而言，随时只能有一个待处理信号。<br>
   原因以及原理如下:<br>
   <img src="markdown图片/屏幕截图 2023-11-26 173139.png" alt="图片alt" title="图片title"><br>
   可以看到，某一类型信号只有一位进行标识，因此某一进程中随时只有一个类型为k的待处理信号。

## 发送信号细节：
1. 命令行kill程序发送信号：

<img src="markdown图片/屏幕截图 2023-11-26 175151.png" alt="图片alt" title="图片title"><br>
**其中的kill：实际kill本意是发送信号给某进程的程序，第一个参数为发送的信号的表示，第二个参数为进程组或者进程**

2. Ctrlc，ctrlz：
   c终止，z挂起（都是向前台进程组发送的信号）。
<img src="markdown图片/屏幕截图 2023-11-26 180206.png" alt="图片alt" title="图片title"><br>