# 链接

静态链接：<br>
<img src="markdown图片/屏幕截图 2023-11-20 210611.png" alt="图片alt" title="图片title"><br>

## 链接器(linker)做了什么：
1. 符号解析<br>
   <img src="markdown图片/屏幕截图 2023-11-20 213510.png" alt="图片alt" title="图片title"><br>
   将各个文件的符号（**全局变量与函数和静态变量**）和他们的引用以结构形式存储在符号表中。<br>
   问题：<br>
   假如不同文件有不同的符号定义，linker需要确定哪一个是用于后续引用的。<br>
2. 重定位
   <img src="markdown图片/屏幕截图 2023-11-20 214643.png" alt="图片alt" title="图片title"><br>
   单一目标的汇编文件中，程序中的各个函数，数据地址只是在该模块中的偏移量，由于地址随机化的原因，不能给出某个模块的绝对地址，因此，重定位的目的是将每个符号定义与每个内存位置关联起来，然后修改符号定义的所有引用，使其指向这些位置。<br>
3. 文件介绍：
   <img src="markdown图片/屏幕截图 2023-11-20 215501.png" alt="图片alt" title="图片title"><br>
   可重定位目标.o文件（二进制文件），链接器链接后产生的可执行文件.out，可共享库文件.so。<br>

## 细节：
   上述几个文件的细节：<br>
1. 可重定位目标文件：由各个字节块组成，指令在一个字节块中，初始化的全局变量在另一块字节序列中，未初始化的又在另外一块中。即单个文件编译后的不同块中，有的包含指令，有的包含目标数据。
2. 可执行目标文件：链接器产生的文件，可以直接被复制到内存中执行。
3. 共享目标文件：一种特殊类型的可重定位目标文件，可在加载和运行时被动态的加载进内存并链接。

### ELF文件格式：
**ELF，可执行，可链接文件的字节序列格式。**<br>
<img src="markdown图片/屏幕截图 2023-11-21 111026.png" alt="图片alt" title="图片title"><br>
补充说明：
1. segment header table（可执行文件必须有）：提供了下列各节的地址和大小，指出了代码不同段在内存中的位置。

下一部分，符号表部分：<br>
<img src="markdown图片/屏幕截图 2023-11-21 113613.png" alt="图片alt" title="图片title"><br>

### 符号
解析前面说的符号:<br>
<img src="markdown图片/屏幕截图 2023-11-21 152454.png" alt="图片alt" title="图片title"><br>
补充说明：<br>
链接器主要负责一下三种符号,**注意局部栈变量由编译器管理，利用栈解决，不属于链接器管理，也因此不在符号表中** <br>
会在符号表中的符号：<br>
1. global symbols：全局符号<br>
   **指在该模块中，定义的可被各模块都可使用的全局函数或变量**。因此，在单一模块编译时，即使某个符号未定义，编译器也不会报错，会认为是在其他模块具体定义的。

2. external symbols：外部符号<br>
   **指该模块引用了，但是在别的模块定义的符号**
3. local symbols：本地符号<br>
   指加了static的**全局**变量和函数，这就是static的作用，这使得该全局变量只能在本模块使用，不能链接到其他模块。<br>
4. 补充，static修饰的局部变量，也会在符号表中：它实际上是一个全局变量，被存在data或bss中（根据初始化与否），但是作用域有只在局部的变量。<br>

## 1.符号解析流程
1. 首先解析符号属性
2. 解析符号强弱，未初始化的变量被认为是弱的，函数和初始化的变量被认为是强的。**因此，多种同名符号，链接器会选择一个强符号，然后其他的弱符号链接到它上面，作为它的引用；所以只能有一个同名的强符号，有多个会报错。**<br>
另外，由多个同名弱符号无强符号的情况，链接器会随机选择一个作为定义，这明显会出现问题，尤其不同模块相同名称类型不同的情况（详见符号表结构）；因此在gcc加入no-common来报错避免该情况。但总的来说，要避免这种情况，尤其不同模块同名变量类型不同的话。**因此，减少全局符号的使用**<br>
若非要使用，解决方案：
<img src="markdown图片/屏幕截图 2023-11-21 172248.png" alt="图片alt" title="图片title"><br>
表明正在使用外部符号extern。<br>

## 2.重定位
1. 可重定位文件到可执行文件：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 181312.png" alt="图片alt" title="图片title"><br>
   注意，其中systemcode部分为lib.c，其从系统调用该程序开始到调用main。<br>
   可执行文件的text会把各个可重定位文件的text放在一起，data也放在一起。
   **重要的是补足其中的地址，见下**<br>
   
2. 可重定位文件细节：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 180621.png" alt="图片alt" title="图片title"><br>
   注意到，main.c中，array和sum都是全局符号，也就是单独编译时，编译器并不知道这两个符号的真正地址，所以以零值代替，并且给出提示要求链接器补足这些地址。<br>
   <img src="markdown图片/屏幕截图 2023-11-21 200544.png" alt="图片alt" title="图片title"><br>
   如上图所示，链接器浏览每个编译器的提示，然后根据链接器排列好的地址，把编译器未补足的地址补足。<br>


### ELF文件格式细节以及其被加载到内存后的内存细节：
<img src="markdown图片/屏幕截图 2023-11-21 202114.png" alt="图片alt" title="图片title"><br>
1. 可执行文件中，ro代码段和数据段才会被加载进内存中，用于调试部分从符号表symtab到strtab的不会。
2. 注意栈堆的位置。

## 库
把一大堆.o文件集合成一个.a文件，然后链接时只复制其中的需要的部分到总的可执行文件中。这样避免每次链接过多的.o文件，也避免链接一个大文件中不需要的其他函数。这就是库技术。<br>

### 静态库：
静态库的构建：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213033.png" alt="图片alt" title="图片title"><br>
使用：<br>

编译：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213916.png" alt="图片alt" title="图片title"><br>
注意，上述编译过程，在命令行中需要按顺序，也就是含有未定义的符号的文件需要在前面输入。
**注意要点**：
静态库链接与.o链接最大不同在于，与.a的静态库链接时，每一个.o程序与其链接，都会复制其中所需的程序的副本。换句话说是每个程序单独复制了，也单独进行的重定位。
<img src="markdown图片/屏幕截图 2023-11-21 222631.png" alt="图片alt" title="图片title"><br>
核心点在于：<br>
链接的颗粒度：直接链接单个目标文件时，链接器可以在所有提供的目标文件中进行符号解析，因此不会重复包含相同的函数。而使用静态库时，每个程序的链接过程是独立的，静态库中的函数会被重复包含在每个使用它的程序中。<br>
程序数量：在直接链接目标文件的例子中，所有的目标文件链接成一个单一的可执行文件。而在使用静态库的例子中，假设有三个独立的程序，每个都链接了包含 func 的静态库，因此每个程序都有自己的 func 副本。<br>

### 动态库
上述静态库问题在于与静态库的链接会在每一个程序和库之间单独进行，这就造成了大量的重复复制。