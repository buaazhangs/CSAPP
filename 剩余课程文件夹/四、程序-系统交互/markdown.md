# 链接

静态链接：<br>
<img src="markdown图片/屏幕截图 2023-11-20 210611.png" alt="图片alt" title="图片title"><br>

## 链接器(linker)做了什么：
1. 符号解析<br>
   <img src="markdown图片/屏幕截图 2023-11-20 213510.png" alt="图片alt" title="图片title"><br>
   将各个文件的符号（**全局变量与函数和静态变量**）和他们的引用以结构形式存储在符号表中。<br>
   问题：<br>
   假如不同文件有不同的符号定义，linker需要确定哪一个是用于后续引用的。<br>
2. 重定位
   <img src="markdown图片/屏幕截图 2023-11-20 214643.png" alt="图片alt" title="图片title"><br>
   单一目标的汇编文件中，程序中的各个函数，数据地址只是在该模块中的偏移量，由于地址随机化的原因，不能给出某个模块的绝对地址，因此，重定位的目的是将每个符号定义与每个内存位置关联起来，然后修改符号定义的所有引用，使其指向这些位置。<br>
3. 文件介绍：
   <img src="markdown图片/屏幕截图 2023-11-20 215501.png" alt="图片alt" title="图片title"><br>
   可重定位目标.o文件（二进制文件），链接器链接后产生的可执行文件.out，可共享库文件.so。<br>

## 细节：
   上述几个文件的细节：<br>
1. 可重定位目标文件：由各个字节块组成，指令在一个字节块中，初始化的全局变量在另一块字节序列中，未初始化的又在另外一块中。即单个文件编译后的不同块中，有的包含指令，有的包含目标数据。
2. 可执行目标文件：链接器产生的文件，可以直接被复制到内存中执行。
3. 共享目标文件：一种特殊类型的可重定位目标文件，可在加载和运行时被动态的加载进内存并链接。

### ELF文件格式：
**ELF，可执行，可链接文件的字节序列格式。**<br>
<img src="markdown图片/屏幕截图 2023-11-21 111026.png" alt="图片alt" title="图片title"><br>
补充说明：
1. segment header table（可执行文件必须有）：提供了下列各节的地址和大小，指出了代码不同段在内存中的位置。

下一部分，符号表部分：<br>
<img src="markdown图片/屏幕截图 2023-11-21 113613.png" alt="图片alt" title="图片title"><br>

### 符号
解析前面说的符号:<br>
<img src="markdown图片/屏幕截图 2023-11-21 152454.png" alt="图片alt" title="图片title"><br>
补充说明：<br>
链接器主要负责一下三种符号,**注意局部栈变量由编译器管理，利用栈解决，不属于链接器管理，也因此不在符号表中** <br>
会在符号表中的符号：<br>
1. global symbols：全局符号<br>
   **指在该模块中，定义的可被各模块都可使用的全局函数或变量**。因此，在单一模块编译时，即使某个符号未定义，编译器也不会报错，会认为是在其他模块具体定义的。

2. external symbols：外部符号<br>
   **指该模块引用了，但是在别的模块定义的符号**
3. local symbols：本地符号<br>
   指加了static的**全局**变量和函数，这就是static的作用，这使得该全局变量只能在本模块使用，不能链接到其他模块。<br>
4. 补充，static修饰的局部变量，也会在符号表中：它实际上是一个全局变量，被存在data或bss中（根据初始化与否），但是作用域有只在局部的变量。<br>

## 1.符号解析流程
1. 首先解析符号属性
2. 解析符号强弱，未初始化的变量被认为是弱的，函数和初始化的变量被认为是强的。**因此，多种同名符号，链接器会选择一个强符号，然后其他的弱符号链接到它上面，作为它的引用；所以只能有一个同名的强符号，有多个会报错。**<br>
另外，由多个同名弱符号无强符号的情况，链接器会随机选择一个作为定义，这明显会出现问题，尤其不同模块相同名称类型不同的情况（详见符号表结构）；因此在gcc加入no-common来报错避免该情况。但总的来说，要避免这种情况，尤其不同模块同名变量类型不同的话。**因此，减少全局符号的使用**<br>
若非要使用，解决方案：
<img src="markdown图片/屏幕截图 2023-11-21 172248.png" alt="图片alt" title="图片title"><br>
表明正在使用外部符号extern。<br>

## 2.重定位
1. 可重定位文件到可执行文件：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 181312.png" alt="图片alt" title="图片title"><br>
   注意，其中systemcode部分为lib.c，其从系统调用该程序开始到调用main。<br>
   可执行文件的text会把各个可重定位文件的text放在一起，data也放在一起。
   **重要的是补足其中的地址，见下**<br>
   
2. 可重定位文件细节：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 180621.png" alt="图片alt" title="图片title"><br>
   注意到，main.c中，array和sum都是全局符号，也就是单独编译时，编译器并不知道这两个符号的真正地址，所以以零值代替，并且给出提示要求链接器补足这些地址。<br>
   <img src="markdown图片/屏幕截图 2023-11-21 200544.png" alt="图片alt" title="图片title"><br>
   如上图所示，链接器浏览每个编译器的提示，然后根据链接器排列好的地址，把编译器未补足的地址补足。<br>


### ELF文件格式细节以及其被加载到内存后的内存细节：
<img src="markdown图片/屏幕截图 2023-11-21 202114.png" alt="图片alt" title="图片title"><br>
1. 可执行文件中，ro代码段和数据段才会被加载进内存中，用于调试部分从符号表symtab到strtab的不会。
2. 注意栈堆的位置。

## 库
把一大堆.o文件集合成一个.a文件，然后链接时只复制其中的需要的部分到总的可执行文件中。这样避免每次链接过多的.o文件，也避免链接一个大文件中不需要的其他函数。这就是库技术。<br>

### 静态库：
静态库的构建：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213033.png" alt="图片alt" title="图片title"><br>
使用：<br>

编译：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213916.png" alt="图片alt" title="图片title"><br>
注意，上述编译过程，在命令行中需要按顺序，也就是含有未定义的符号的文件需要在前面输入。
**注意要点**：
静态库链接与.o链接最大不同在于，与.a的静态库链接时，每一个.o程序与其链接，都会复制其中所需的程序的副本。换句话说是每个程序单独复制了，也单独进行的重定位。
<img src="markdown图片/屏幕截图 2023-11-21 222631.png" alt="图片alt" title="图片title"><br>
核心点在于：<br>
链接的颗粒度：直接链接单个目标文件时，链接器可以在所有提供的目标文件中进行符号解析，因此不会重复包含相同的函数。而使用静态库时，每个程序的链接过程是独立的，静态库中的函数会被重复包含在每个使用它的程序中。<br>
程序数量：在直接链接目标文件的例子中，所有的目标文件链接成一个单一的可执行文件。而在使用静态库的例子中，假设有三个独立的程序，每个都链接了包含 func 的静态库，因此每个程序都有自己的 func 副本。<br>

### 动态库
上述静态库问题在于与静态库的链接会在每一个程序和库之间单独进行，这就造成了大量的重复复制。<br>
1. 动态库（共享库）可以让可执行文件无需复制多个相同的代码段
2. 动态库可以让程序对库文件的调用在程序被加载（load time）进内存时复制，甚至可以在程序在内存中运行时(run time)复制。
3. 共享库可以被多个进程共享<br>
工作原理:
<img src="markdown图片/屏幕截图 2023-11-22 112134.png" alt="图片alt" title="图片title"><br>
如图，动态链接会在符号表中记录下对库中函数的引用，但是与静态库不同，它只是记下引用，是个部分链接，不会真的复制进去。函数的真正复制在程序运行时进行。<br>

库打桩技术：<br>


# 异常控制流
## 异常和进程
软件层面的异常控制，主要条件跳转，程序调用和返回等。<br>
操作系统层面的控制流跳转：硬件异常，进程切换，非正常函数跳转等<br>
### 异常
异常，是指将低级别的控制权转换回内核，什么是内核？<br>
**内核，指的是在内存中始终预留的操作系统的相关程序**<br>
<img src="markdown图片/屏幕截图 2023-11-22 154817.png" alt="图片alt" title="图片title"><br>
上图显示了异常调用，从用户态转为内核态，并在内核态的异常处理程序结束后，有如图的三种返回方式,返回目前程序指针，或者下一程序指针，或者abort终止。<br>

### 异常的类型与实现：
1. 硬件软件分类<br>
处理器异常：除0，内存访问违例，溢出，断点等；<br>
操作系统异常：系统调用,IO等<br>
**异常跳转**：<br>
运行时，处理器检测发生事件->确定异常号->触发异常->跳转异常表，再跳转表中地址。<br>
**异常跳转与过程调用的区别：**<br>
<img src="markdown图片/屏幕截图 2023-11-22 161029.png" alt="图片alt" title="图片title"><br>
2. 同步异步<br>
   A.异步异常（中断）：处理器外部发生了状态变化引起的，通过中断引脚告知处理器。例如，从磁盘拷贝到内存中，拷贝完成，向中断引脚发送一条信息（IO中断）。  
   B. 同步异常：  
   一、 trap陷阱异常，程序为达成某目的故意引起的异常：<br>
   例如：**系统调用**，调试断点，特殊指令等。  
   系统调用，内核代码能提供各种程序本身没有权限执行的服务，例如调用内核中的函数，以此发出对各种服务的请求。<br>
   **这个异常返回程序的下一个指令**<br>
   二、fault故障异常，**可能可以**被修复的错误：<br>
   例如：页缺失，即程序访问的内存段未在内存中，需要从磁盘拷入,这是可以修复的。保护故障，例如访问未被分配的内存段，这个不可被修复。<br>
   三、aborts中止异常，无意且不可恢复的异常：<br>
   一些非法的指令。**这个异常不会返回程序。**

### 详细介绍：
1. 以write函数为例介绍系统调用中的打开文件：<br>
   syscall函数，直接进行系统调用的函数，接收系统调用参数作为参数，但是一般不直接用它，使用包装后的系统函数<br>
   系统调用函数，**通过寄存器传递值，不通过栈**。rax为系统调用编号，6参数寄存器依然作为参数传递。  
   系统函数：包装了上述syscall函数。  
   以write来写printf：
   <img src="markdown图片/屏幕截图 2023-11-22 173733.png" alt="图片alt" title="图片title"><br>
   将write的系统调用id1放入rax中，其余参数放图rdi，rsi，rdx等中，然后执行syscall。<br>
2. fault,以页缺失为例。
   访问一个地址，有可能该地址还未在内存中，这时候调用系统页缺失程序，然后返回该访问指令<br>
   也有可能该地址是虚拟地址空间中的无效区域，因此这时候为无法修复的错误，此时他会向进程发送信号SIGSEGV，进程会返回段错误<br>
   例如下面的情况：<br>
   <img src="markdown图片/屏幕截图 2023-11-22 175856.png" alt="图片alt" title="图片title"><br>


# 进程
正在运行的程序的实例，系统中的每个程序都运行在每个进程的上下文中。<br>
上下文，由程序运行的状态构成，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量，以及打开文件描述符等的集合<br>

**进程提供以下两个抽象：**
1. 看起来独占逻辑控制流，独占CPU上的寄存器。
2. 看起来独占内存地址空间(虚拟内存机制)<br>
上面提供的两个抽象，让你在一个程序运行时，不用担心你的各种数值被修改，你的寄存器值是独一无二的,你的内存地址也是独一无二的。<br>

## 几个基本概念：
1. **并发**：
   两个逻辑流的执行在时间上重叠，即称为并发流，称这两个流并发的运行。<br>
   **与并行的区别：**<br>
   注意，并发只是逻辑流的概念，只要两个流在时间上有重叠就是并发的，即使它们运行在同一处理器上。那么，什么是并行：只要两个并发的逻辑流实现在不同的核或者不同的计算机上面，那就是两个并行的执行的并发流。<br>
   **时间节省**：<br>
   一般来说，能并行执行的并发逻辑流都是能省时间的，而由于要进行上下文切换，如果只在单核上，大多数情况会导致性能的下降，但并非都会下降，也要具体情况具体分析。<br>
   例如某些任务，一个逻辑流需要长时间计算，另一个逻辑流需要持续待机回应响应，这时候的进程切换就会有节省时间的作用。<br>
   或者某进程从磁盘read，等待read完成的过程中就可以切换到另一进程，**注意这样做能实现的原因是磁盘到内存无需CPU**<br>
2. **私有地址空间**：
   每个进程独有一段自己的私有地址空间，和该空间相关联（**这个地方换句话说，私有地址空间并非直接是物理内存地址**）的内存地址是不能被其他内存读和写的。
   
3. **用户模式和内核模式**：
   为了实现对进程的抽象，处理器必须提供一个标识，让它能够标注一个应用可以执行的指令和它可以访问的地址范围。<br>
   因此，处理器中有一个模式位，标识了当前的权限。用户模式下，程序不能执行某些指令，例如停止CPU，改变模式位，或者发起一个IO操作；不能读取某些地址，例如内核空间的地址。<br>
   一个应用程序，一开始总是从用户模式开始，而且只能通过异常，将模式转为内核模式。<br>

## 多进程切换样例（上下文切换）：
上下文：内核重新启动一个被强占的进程，所需的状态。即该进程的某些对象，包括**寄存器值**，程序计数器，**堆栈指针**；描述地址空间的页表，当前进程信息的进程表等。<br>
调度：在当前进程运行的某个时刻，内核可以决定暂停当前进程，并重新开始一个之前被抢占了的进程，这就是调度。调度具体实现是由**上下文切换**实现<br>
上下文切换分为下面三步：<br>
1. 保存当前进程的上下文，**保存进位于内核空间的进程控制块中**
2. 恢复之前被抢占进程的上下文
3. 将控制传递给恢复的进程<br>
注意，上下文不用保存进程在内存中的东西，进程不结束这些东西都在内存中保留。<br>
引发上下文切换的方式有很多，例如**系统调用**，系统调用后某进程因为等待而阻塞；或者定时器终端等。<br>

# 进程控制：
从C程序中进行系统调用的系统级C函数（对syscall的包装）。
1. fork:<br>
   int fork(void)<br>
   原始fork，开启该进程的子进程，并返回开启的子进程的id，返回-1代表失败。<br>
   另外，由于对于系统调用级别函数，如果失败一般要让当前进程停止(exit),因此一般可用一个函数包装fork，返回-1时报错并退出。<br>
2. getpid,getppid 
3. 进程的三种运行态：  
   running:运行或**未运行但是可以被调度**  
   stopped：进程被挂起，**且不会被调度**，受信号控制，**信号是软件中断的一种形式**  
   terminated:终止，进程永远的终止了。有三个原因终止：1）.收到某个信号，它的默认行为是终止进程；2）.从主程序返回；3）.调用exit函数。

1. 创建进程，fork函数详解：<br>
   **子进程创建后，复制父进程的整个内存，包括代码和数据，堆栈，程序计数器，共享库，文件描述符等，但注意，它是一个全新的进程，与父进程隔离，且拥有不同的pid**<br>
   **因此，实际上在一个程序中执行多个进程，就是使用pid来区分**，例如下述程序：<br>
   <img src="markdown图片/屏幕截图 2023-11-23 215333.png" alt="图片alt" title="图片title"><br>
   上述程序的几点：<br>
   1. 调用一次，返回两次，注意返回两次指的是父进程和子进程的分别返回，在父进程它返回子进程的pid，子进程返回0，因此，我们上图的程序才能通过**pid == 0的方式识别是哪个进程，因为程序都是一样的**。
   2. 相同但独立的地址空间：fork执行时，子进程将有父进程的一切并且相同，但是这之后就是独立的了，所以两个x在输出时是不同的。
   3. 共享文件，它们都将输出打印在标准输出上了。
   4. 进程图：