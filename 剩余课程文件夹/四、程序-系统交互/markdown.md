# 链接

静态链接：<br>
<img src="markdown图片/屏幕截图 2023-11-20 210611.png" alt="图片alt" title="图片title"><br>

## 链接器(linker)做了什么：
1. 符号解析<br>
   <img src="markdown图片/屏幕截图 2023-11-20 213510.png" alt="图片alt" title="图片title"><br>
   将各个文件的符号（**全局变量与函数和静态变量**）和他们的引用以结构形式存储在符号表中。<br>
   问题：<br>
   假如不同文件有不同的符号定义，linker需要确定哪一个是用于后续引用的。<br>
2. 重定位
   <img src="markdown图片/屏幕截图 2023-11-20 214643.png" alt="图片alt" title="图片title"><br>
   单一目标的汇编文件中，程序中的各个函数，数据地址只是在该模块中的偏移量，由于地址随机化的原因，不能给出某个模块的绝对地址，因此，重定位的目的是将每个符号定义与每个内存位置关联起来，然后修改符号定义的所有引用，使其指向这些位置。<br>
3. 文件介绍：
   <img src="markdown图片/屏幕截图 2023-11-20 215501.png" alt="图片alt" title="图片title"><br>
   可重定位目标.o文件（二进制文件），链接器链接后产生的可执行文件.out，可共享库文件.so。<br>

## 细节：
   上述几个文件的细节：<br>
1. 可重定位目标文件：由各个字节块组成，指令在一个字节块中，初始化的全局变量在另一块字节序列中，未初始化的又在另外一块中。即单个文件编译后的不同块中，有的包含指令，有的包含目标数据。
2. 可执行目标文件：链接器产生的文件，可以直接被复制到内存中执行。
3. 共享目标文件：一种特殊类型的可重定位目标文件，可在加载和运行时被动态的加载进内存并链接。

### ELF文件格式：
**ELF，可执行，可链接文件的字节序列格式。**<br>
<img src="markdown图片/屏幕截图 2023-11-21 111026.png" alt="图片alt" title="图片title"><br>
补充说明：
1. segment header table（可执行文件必须有）：提供了下列各节的地址和大小，指出了代码不同段在内存中的位置。

下一部分，符号表部分：<br>
<img src="markdown图片/屏幕截图 2023-11-21 113613.png" alt="图片alt" title="图片title"><br>

### 符号
解析前面说的符号:<br>
<img src="markdown图片/屏幕截图 2023-11-21 152454.png" alt="图片alt" title="图片title"><br>
补充说明：<br>
链接器主要负责一下三种符号,**注意局部栈变量由编译器管理，利用栈解决，不属于链接器管理，也因此不在符号表中** <br>
会在符号表中的符号：<br>
1. global symbols：全局符号<br>
   **指在该模块中，定义的可被各模块都可使用的全局函数或变量**。因此，在单一模块编译时，即使某个符号未定义，编译器也不会报错，会认为是在其他模块具体定义的。

2. external symbols：外部符号<br>
   **指该模块引用了，但是在别的模块定义的符号**
3. local symbols：本地符号<br>
   指加了static的**全局**变量和函数，这就是static的作用，这使得该全局变量只能在本模块使用，不能链接到其他模块。<br>
4. 补充，static修饰的局部变量，也会在符号表中：它实际上是一个全局变量，被存在data或bss中（根据初始化与否），但是作用域有只在局部的变量。<br>

## 1.符号解析流程
1. 首先解析符号属性
2. 解析符号强弱，未初始化的变量被认为是弱的，函数和初始化的变量被认为是强的。**因此，多种同名符号，链接器会选择一个强符号，然后其他的弱符号链接到它上面，作为它的引用；所以只能有一个同名的强符号，有多个会报错。**<br>
另外，由多个同名弱符号无强符号的情况，链接器会随机选择一个作为定义，这明显会出现问题，尤其不同模块相同名称类型不同的情况（详见符号表结构）；因此在gcc加入no-common来报错避免该情况。但总的来说，要避免这种情况，尤其不同模块同名变量类型不同的话。**因此，减少全局符号的使用**<br>
若非要使用，解决方案：
<img src="markdown图片/屏幕截图 2023-11-21 172248.png" alt="图片alt" title="图片title"><br>
表明正在使用外部符号extern。<br>

## 2.重定位
1. 可重定位文件到可执行文件：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 181312.png" alt="图片alt" title="图片title"><br>
   注意，其中systemcode部分为lib.c，其从系统调用该程序开始到调用main。<br>
   可执行文件的text会把各个可重定位文件的text放在一起，data也放在一起。
   **重要的是补足其中的地址，见下**<br>
   
2. 可重定位文件细节：<br>
   <img src="markdown图片/屏幕截图 2023-11-21 180621.png" alt="图片alt" title="图片title"><br>
   注意到，main.c中，array和sum都是全局符号，也就是单独编译时，编译器并不知道这两个符号的真正地址，所以以零值代替，并且给出提示要求链接器补足这些地址。<br>
   <img src="markdown图片/屏幕截图 2023-11-21 200544.png" alt="图片alt" title="图片title"><br>
   如上图所示，链接器浏览每个编译器的提示，然后根据链接器排列好的地址，把编译器未补足的地址补足。<br>


### ELF文件格式细节以及其被加载到内存后的内存细节：
<img src="markdown图片/屏幕截图 2023-11-21 202114.png" alt="图片alt" title="图片title"><br>
1. 可执行文件中，ro代码段和数据段才会被加载进内存中，用于调试部分从符号表symtab到strtab的不会。
2. 注意栈堆的位置。

## 库
把一大堆.o文件集合成一个.a文件，然后链接时只复制其中的需要的部分到总的可执行文件中。这样避免每次链接过多的.o文件，也避免链接一个大文件中不需要的其他函数。这就是库技术。<br>

### 静态库：
静态库的构建：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213033.png" alt="图片alt" title="图片title"><br>
使用：<br>

编译：<br>
<img src="markdown图片/屏幕截图 2023-11-21 213916.png" alt="图片alt" title="图片title"><br>
注意，上述编译过程，在命令行中需要按顺序，也就是含有未定义的符号的文件需要在前面输入。
**注意要点**：
静态库链接与.o链接最大不同在于，与.a的静态库链接时，每一个.o程序与其链接，都会复制其中所需的程序的副本。换句话说是每个程序单独复制了，也单独进行的重定位。
<img src="markdown图片/屏幕截图 2023-11-21 222631.png" alt="图片alt" title="图片title"><br>
核心点在于：<br>
链接的颗粒度：直接链接单个目标文件时，链接器可以在所有提供的目标文件中进行符号解析，因此不会重复包含相同的函数。而使用静态库时，每个程序的链接过程是独立的，静态库中的函数会被重复包含在每个使用它的程序中。<br>
程序数量：在直接链接目标文件的例子中，所有的目标文件链接成一个单一的可执行文件。而在使用静态库的例子中，假设有三个独立的程序，每个都链接了包含 func 的静态库，因此每个程序都有自己的 func 副本。<br>

### 动态库
上述静态库问题在于与静态库的链接会在每一个程序和库之间单独进行，这就造成了大量的重复复制。<br>
1. 动态库（共享库）可以让可执行文件无需复制多个相同的代码段
2. 动态库可以让程序对库文件的调用在程序被加载（load time）进内存时复制，甚至可以在程序在内存中运行时(run time)复制。
3. 共享库可以被多个进程共享<br>
工作原理:
<img src="markdown图片/屏幕截图 2023-11-22 112134.png" alt="图片alt" title="图片title"><br>
如图，动态链接会在符号表中记录下对库中函数的引用，但是与静态库不同，它只是记下引用，是个部分链接，不会真的复制进去。函数的真正复制在程序运行时进行。<br>

库打桩技术：<br>


# 异常控制流
## 异常和进程
软件层面的异常控制，主要条件跳转，程序调用和返回等。<br>
操作系统层面的控制流跳转：硬件异常，进程切换，非正常函数跳转等<br>
### 异常
异常，是指将低级别的控制权转换回内核，什么是内核？<br>
**内核，指的是在内存中始终预留的操作系统的相关程序**<br>
<img src="markdown图片/屏幕截图 2023-11-22 154817.png" alt="图片alt" title="图片title"><br>
上图显示了异常调用，从用户态转为内核态，并在内核态的异常处理程序结束后，有如图的三种返回方式,返回目前程序指针，或者下一程序指针，或者abort终止。<br>

### 异常的类型与实现：
1. 硬件软件分类<br>
处理器异常：除0，内存访问违例，溢出，断点等；<br>
操作系统异常：系统调用,IO等<br>
**异常跳转**：<br>
运行时，处理器检测发生事件->确定异常号->触发异常->跳转异常表，再跳转表中地址。<br>
**异常跳转与过程调用的区别：**<br>
<img src="markdown图片/屏幕截图 2023-11-22 161029.png" alt="图片alt" title="图片title"><br>
2. 同步异步<br>
   A.异步异常（中断）：处理器，程序外部发生了状态变化引起的，通过中断引脚告知处理器。例如，从磁盘拷贝到内存中，拷贝完成，向中断引脚发送一条信息（IO中断）。  
   B. 同步异常：  
   一、 trap陷阱异常，程序为达成某目的故意引起的异常：<br>
   例如：**系统调用syscall**，调试断点，特殊指令等。  
   系统调用，内核代码能提供各种程序本身没有权限执行的服务，例如调用内核中的函数，以此发出对各种服务的请求。<br>
   **这个异常返回程序的下一个指令**<br>
   二、fault故障异常，**可能可以**被修复的错误：<br>
   例如：页缺失，即程序访问的内存段未在内存中，需要从磁盘拷入,这是可以修复的。保护故障，例如访问未被分配的内存段，这个不可被修复。<br>
   三、aborts中止异常，无意且不可恢复的异常：<br>
   一些非法的指令。**这个异常不会返回程序。**

### 详细介绍：
1. 以write函数为例介绍系统调用中的打开文件：<br>
   syscall函数，直接进行系统调用的函数，接收系统调用参数作为参数，但是一般不直接用它，使用包装后的系统函数<br>
   系统调用函数，**通过寄存器传递值，不通过栈**。rax为系统调用编号，6参数寄存器依然作为参数传递。  
   系统函数：包装了上述syscall函数。  
   以write来写printf：
   <img src="markdown图片/屏幕截图 2023-11-22 173733.png" alt="图片alt" title="图片title"><br>
   将write的系统调用id1放入rax中，其余参数放图rdi，rsi，rdx等中，然后执行syscall。<br>
2. fault,以页缺失为例。
   访问一个地址，有可能该地址还未在内存中，这时候调用系统页缺失程序，然后返回该访问指令<br>
   也有可能该地址是虚拟地址空间中的无效区域，因此这时候为无法修复的错误，此时他会向进程发送信号SIGSEGV，进程会返回段错误<br>
   例如下面的情况：<br>
   <img src="markdown图片/屏幕截图 2023-11-22 175856.png" alt="图片alt" title="图片title"><br>


# 进程
正在运行的程序的实例，系统中的每个程序都运行在每个进程的上下文中。<br>
上下文，由程序运行的状态构成，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量，以及打开文件描述符等的集合<br>

**进程提供以下两个抽象：**
1. 看起来独占逻辑控制流，独占CPU上的寄存器。
2. 看起来独占内存地址空间(虚拟内存机制)<br>
上面提供的两个抽象，让你在一个程序运行时，不用担心你的各种数值被修改，你的寄存器值是独一无二的,你的内存地址也是独一无二的。<br>

## 几个基本概念：
1. **并发**：
   两个逻辑流的执行在时间上重叠，即称为并发流，称这两个流并发的运行。<br>
   **与并行的区别：**<br>
   注意，并发只是逻辑流的概念，只要两个流在时间上有重叠就是并发的，即使它们运行在同一处理器上。那么，什么是并行：只要两个并发的逻辑流实现在不同的核或者不同的计算机上面，那就是两个并行的执行的并发流。<br>
   **时间节省**：<br>
   一般来说，能并行执行的并发逻辑流都是能省时间的，而由于要进行上下文切换，如果只在单核上，大多数情况会导致性能的下降，但并非都会下降，也要具体情况具体分析。<br>
   例如某些任务，一个逻辑流需要长时间计算，另一个逻辑流需要持续待机回应响应，这时候的进程切换就会有节省时间的作用。<br>
   或者某进程从磁盘read，等待read完成的过程中就可以切换到另一进程，**注意这样做能实现的原因是磁盘到内存无需CPU**<br>
2. **私有地址空间**：
   每个进程独有一段自己的私有地址空间，和该空间相关联（**这个地方换句话说，私有地址空间并非直接是物理内存地址**）的内存地址是不能被其他内存读和写的。
   
3. **用户模式和内核模式**：
   为了实现对进程的抽象，处理器必须提供一个标识，让它能够标注一个应用可以执行的指令和它可以访问的地址范围。<br>
   因此，处理器中有一个模式位，标识了当前的权限。用户模式下，程序不能执行某些指令，例如停止CPU，改变模式位，或者发起一个IO操作；不能读取某些地址，例如内核空间的地址。<br>
   一个应用程序，一开始总是从用户模式开始，而且只能通过异常，将模式转为内核模式。<br>
   **因此，实际上内存中只有一个内核模式空间，其余内存段为多个用户模式（多个进程）**<br>
   可参见下图的解析：<br>
   <img src="markdown图片/屏幕截图 2023-11-27 152537.png" alt="图片alt" title="图片title"><br>
   <img src="markdown图片/屏幕截图 2023-11-27 152636.png" alt="图片alt" title="图片title"><br>

## 多进程切换样例（上下文切换）：
上下文：内核重新启动一个被强占的进程，所需的状态。即该进程的某些对象，包括**寄存器值**，程序计数器，**堆栈指针**；描述地址空间的页表，当前进程信息的进程表等。<br>
调度：在当前进程运行的某个时刻，内核可以决定暂停当前进程，并重新开始一个之前被抢占了的进程，这就是调度。调度具体实现是由**上下文切换**实现<br>
上下文切换分为下面三步：<br>
1. 保存当前进程的上下文，**保存进位于内核空间的进程控制块中**
2. 恢复之前被抢占进程的上下文
3. 将控制传递给恢复的进程<br>
注意，上下文不用保存进程在内存中的东西，进程不结束这些东西都在内存中保留。<br>
引发上下文切换的方式有很多，例如**系统调用**，系统调用后某进程因为等待而阻塞；或者定时器终端等。<br>

# 进程控制：
从C程序中进行系统调用的系统级C函数（对syscall的包装）。
1. fork:<br>
   int fork(void)<br>
   原始fork，开启该进程的子进程，并返回开启的子进程的id，返回-1代表失败。<br>
   另外，由于对于系统调用级别函数，如果失败一般要让当前进程停止(exit),因此一般可用一个函数包装fork，返回-1时报错并退出。<br>
2. getpid,getppid 
3. 进程的三种运行态：  
   running:运行或**未运行但是可以被调度**  
   stopped：进程被挂起，**且不会被调度**，受信号控制，**信号是软件中断的一种形式**  
   terminated:终止，进程永远的终止了。有三个原因终止：1）.收到某个信号，它的默认行为是终止进程；2）.从主程序返回；3）.调用exit函数。

一、创建进程，fork函数详解：<br>
   **子进程创建后，复制父进程的整个内存，包括代码和数据，堆栈，程序计数器，共享库，文件描述符等，但注意，它是一个全新的进程，与父进程隔离，且拥有不同的pid**<br>
   **因此，实际上在一个程序中执行多个进程，就是使用pid来区分**，例如下述程序：<br>
   <img src="markdown图片/屏幕截图 2023-11-23 215333.png" alt="图片alt" title="图片title"><br>
   上述程序的几点：<br>
   1. 调用一次，返回两次，注意返回两次指的是父进程和子进程的分别返回，在父进程它返回子进程的pid，子进程返回0，因此，我们上图的程序才能通过**pid == 0的方式识别是哪个进程，因为程序都是一样的**。
   2. 相同但独立的地址空间：fork执行时，子进程将有父进程的一切并且相同，但是这之后就是独立的了，所以两个x在输出时是不同的。
   3. 共享文件，它们都将输出打印在标准输出上了。
   4. 进程图：
   利用进程图+**拓扑排序**的思想来分析多进程代码。<br>
   **特别注意，图顺序只有说a->b的情况下，b一定不能在a之前发生，但是如果没有节点之间的边，则不能判断进程的先后性，如下图：<br>
   <img src="markdown图片/屏幕截图 2023-11-24 112845.png" alt="图片alt" title="图片title"><br>
   注意，**进程发生先后顺序并非是层序遍历**，即在一个节点之后的所有节点，**（那些没有先后关系的，进程执行的顺序是不定的）**。<br>

二、 终止进程，僵尸进程状态：<br>
子进程终止->进入**僵尸进程态**(ps查看的defunct标识)->父进程回收（reap），内核将子进程的退出状态传递给父进程->彻底抛弃已终止的进程。<br>
对于父进程提前终止，尚未回收的子进程，称为孤儿进程，这些进程的退出状态保存在内核空间中，有占用。因此系统让id = 1的init进程负责回收。<br>

三、**使用waitpid处理终止进程的状态，以及控制进程先后性。**<br>
**如果父进程不使用waitpid处理子进程，那么子进程就是僵尸状态进程（defunct），如果父进程提前终止了，那么僵尸子进程就会被init进程回收**<br>
我们知道，子进程被创建后，
wait函数介绍：int wait(int *child_status)<br>
waitpid函数：pid_t waitpid(_pid_t pid, int *statusp,int options):<br>
解析：<br>
waitpid函数执行后，会挂起当前的进程的执行，直到它的等待集合（wait set）中的**一个**子进程终止或停止，如果等待集合中只要有一个进程在waitpid调用时就是终止的，则会立即返回。  
1. 返回：在上述两种情况中，会返回等待集合中的那个终止的子进程的pid。如果被调用进程没有子进程，或被一个信号中断，返回-1。
2. pid：pid == -1,则等待集合为该进程的所有子进程，pid>0,则等待集合为该pid的进程。
3. option，可以通过修改该值来调整waitpid的行为，细节见课本。
4. statusp：传入该指针，然后waitpid会在该指针指向的位置（要求非空）存放waitset中导致返回的哪一个子进程的状态信息。
wait函数是waitpid的简化版，int wait(&status) == _pid_t waitpid(-1,&status,0)  
<img src="markdown图片/屏幕截图 2023-11-24 154454.png" alt="图片alt" title="图片title"><br>
此时，进程图就变为了彻底需要拓扑排序来判断执行顺序的情况了，如上图所示。<br>

三、暂停与休眠：<br>
sleep(秒数)，pause；sleep会被信号提前打断，pause只有被信号打断才会继续进行。  

四、加载运行其他程序：<br>
execve,启动一个新的程序的进程：<br>
int execve(const char \*filename,const char \*argv[],const char \*envp[])  
execve提供可执行文件的文件名，以及该文件需要的参数argv和envp(**他们为一个指针数组，每个指针指向一个char\*，也就是字符串,如1中图所示**)，该函数除非调用失败会返回，否则**从不返回**。

**execve的调用一次且不返回，是指使用execve的当前进程，其所占的内存空间整个的都会被新调用的程序所占用，也就是当前进程整个的切换为新调用的程序了(不是开一个新进程)**<br>
**execve 系统调用用于在当前进程的上下文中执行一个新程序。当 execve 被调用时，它会加载新程序的代码和数据，替换当前进程的代码和数据，而当前进程的执行则结束。这就是为什么说 execve 调用一次且不返回（除非有错误发生）。**<br>
1. 上述上下文执行新程序的保留内容和替换内容：  
   <img src="markdown图片/屏幕截图 2023-11-24 173808.png" alt="图片alt" title="图片title"><br>
   上图1中的，代码数据段，堆栈等都是在内存用户区，而pid，文件描述符这些都在内存内核区域中。<br>
2. 启动新程序的传参和main函数解析<br>
   具体来说，execve执行了filename的程序后，其调用启动代码，然后将控制传递给新程序的main，如下所示：  
   int main(int argc,int **argv,char ** envp) 
   <img src="markdown图片/屏幕截图 2023-11-24 170329.png" alt="图片alt" title="图片title"><br>
   系统将这些的结构覆盖进程的上下文，然后将控制权交换到用户态的main函数位置。<br>
   <img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
   argv，envp都是传给新程序的参数，但其有区别：<br>
   argv:使程序能够接收用户输入的参数，这对于指导程序的运行行为非常重要<br>
   envp：提供了一种机制，通过它，操作系统和运行环境可以传递配置信息给程序，无需改变程序代码。环境变量对于配置程序行为、设定资源路径和控制程序运行的环境非常有用。<br>
   
3. fork+execve的组合使用：<br>
   由于execve执行后就不再返回，相当于当前进程就这么结束了,后面的代码都无效了，因此一般用fork开一个子进程来执行加载别的程序<br>

# 信号
几个概念：<br>
1. 外部事件，异步事件：  
   上述两种都指的进程控制流之外的事件。但是强调的点不同:
   <img src="markdown图片/屏幕截图 2023-11-26 163959.png" alt="图片alt" title="图片title"><br>
2. 同步事件：<br>
   <img src="markdown图片/屏幕截图 2023-11-26 164511.png" alt="图片alt" title="图片title"><br>

## shell，linux进程架构：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
shell命令的实现：
<img src="markdown图片/屏幕截图 2023-11-24 174627.png" alt="图片alt" title="图片title"><br>
执行eval函数计算表达式：<br>

eval函数解析：<br>


## 信号概念以及实现方式：
**信号概念**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 163355.png" alt="图片alt" title="图片title"><br>
信号实现方式：**内核给目标进程发送或传递一个信号，通过为目标进程的上下文设置一些状态来实现.**<br>
注：信号对于接收的程序来说，是一种异步的行为。<br>

**进程接收到信号的处理方式**：<br>
<img src="markdown图片/屏幕截图 2023-11-26 160300.png" alt="图片alt" title="图片title"><br>
如图所示，进程接收到信号后，进程的某些上下文状态会改变，此时进程会有三种回应该信号的方式：<br>
1. 忽视该信号
2. 终止进程
3. catch，进入信号处理程序。这里类似中断，但是**异常处理程序都在内核态中，而信号处理程序都是C代码，位于用户态**

**信号特点**：<br>
1. 某一进程，对某一类信号而言，随时只能有一个待处理信号。<br>
   原因以及原理如下:<br>
   <img src="markdown图片/屏幕截图 2023-11-26 173139.png" alt="图片alt" title="图片title"><br>
   可以看到，某一类型信号只有一位进行标识，因此某一进程中随时只有一个类型为k的待处理信号。

## 发送信号细节：
1. 命令行kill程序发送信号：

<img src="markdown图片/屏幕截图 2023-11-26 175151.png" alt="图片alt" title="图片title"><br>
**其中的kill：实际kill本意是发送信号给某进程的程序，第一个参数为发送的信号的表示，第二个参数为进程组或者进程**

2. Ctrlc，ctrlz：
   c终止，z挂起（都是向前台进程组发送的信号）。
<img src="markdown图片/屏幕截图 2023-11-26 180206.png" alt="图片alt" title="图片title"><br>

3. shell
4. kill函数
5. alarm函数  
   上述函数细节可参看课本。  

## 接收信号
每当程序由内核态转为某进程P的用户态时，它都会先检查该进程的待处理信号集合，即信号接收标识pending和阻塞标识blocking：**（pending & ~blocking）**。之后，会有下列两种情况：<br>
1. 集合为空，则执行p的程序计数器指针位置（即Inext）
2. 集合非空，内核强制选择集合中某个信号（一般是最小的那个k），该进程会进行接收信号行为。一旦进程完成了该行为而不终止，则完成该行为后会执行Inext。
   
### 接收信号行为：
1. 各种信号都有默认行为，例如终止，停止，忽略等
2. 修改的行为，程序可以自己写signal函数修改默认信号处理行为。可见代码signal对ctrlc的修改：<br>
<img src="markdown图片/屏幕截图 2023-11-27 163807.png" alt="图片alt" title="图片title"><br>
如图所示，signal可对第一个参数所标识的信号的默认行为进行修改，将其修改为第二个参数指向的函数(假设为sigfuc)。sighandler_t类型意思为void类型返回的函数指针，其函数参数为int。<br>
因此signal函数执行时，将该函数编号传递给信号处理函数sigfuc，然后信号处理函数进行处理。对于signal函数来说，信号处理成果则返回sigfuc的指针，若调用失败则返回SIG_ERR。
3. 信号处理函数可以被其他信号处理函数中断，**正如信号处理函数依然是用户态函数一样，其他信号处理函数结束后依然会回到该信号处理函数**：  
   这依然是一种异步行为，即你没办法定义信号处理函数什么时候会被接收到别的信号去中断它，除非你pause挂起了。
4. 另外，信号的处理是由系统管理的，也就是你处理程序的跳转**是直接调转到signal函数的第二个参数的指定的位置的**，然后执行结果返回哪一个位置也是系统管理的。

### 信号是并发的一种形式
这种是在同一进程内部的并发工作流，会带来很多问题：<br>
<img src="markdown图片/屏幕截图 2023-11-27 201125.png" alt="图片alt" title="图片title"><br>

### 阻塞
默认阻塞：某类信号处理程序在执行时，会默认阻塞相同的信号类型  
用户态控制：
sigprocmask等函数，**用于防止关键代码段执行时被异步信号打断，可用于实现原子操作**



   
### 信号处理程序的三个要点：
1. 并发性，因此对某些数据的修改要注意安全和一致性
<img src="markdown图片/屏幕截图 2023-11-27 203353.png" alt="图片alt" title="图片title"><br>
printf就不是一个异步信号安全的函数，因为printf会给终端上锁，而printf本身会中断，如果printf执行过程中进入内核态，此时又有信号过来，该信号处理程序中也有printf的话，就会死锁了。  
详情见课本：<br>
2. 无队列性，某个类型的信号是始终只有一个的，不排队。因此你不能利用信号处理程序统计有多少个信号到达过该进程。<br>
见sigchild.c代码，sigchild信号为子进程终止或者停止时发送给父进程的信号，然鹅，不能使用信号处理程序统计某一进程收到了多少信号。详见代码sigchild.c<br>
上述子进程信号程序引发一个思考就是，如何利用SIGCHILD信号检测子进程的终止或停止：<br>
需要用waitpid来在一个信号到达时处理所有等待的子进程<br>

### 信号处理函数与并行流
信号处理函数天然是一个并行流，因此需要考虑的东西就变多了。<br>

### 进程如何显式的等待信号来运行：
例如进程需要子进程结束的信息来进一步运行，可以见函数waitchild.c:<br>
<img src="markdown图片/屏幕截图 2023-11-28 204616.png" alt="图片alt" title="图片title"><br>
在sigchild的信号处理程序中，设置全局的pid！=0，然后主进程中的while即可结束循环。<br>
**上面的方法是对的，但是while过程执行的太久，占有时间长**  
下列修复方法：<br>
<img src="markdown图片/屏幕截图 2023-11-28 205102.png" alt="图片alt" title="图片title"><br>
左边的方法实际上会有问题，加入sigchild信号在while和pause之间到达，那么就永远不会解决pause了。右边的方法又太慢了。<br>
因此，可以想到解决方案为在左边的pause处加入信号阻塞，**在pause执行时接受sigchil,执行后又不能接受sigchil了，并且一定要保证这几步在一起进行，否则依然会出现开启接收sigchild然后马上就有信号的问题**，听起来是一个不可能实现的操作，但实际上可以用原子操作实现，如下所示：<br>
<img src="markdown图片/屏幕截图 2023-11-28 210144.png" alt="图片alt" title="图片title"><br>
即上图的三个指令是一起执行的，不可被中断，**关掉对sigchild的阻塞，暂停，开启对sigchild的阻塞**这里面前两步是一起进行的。
注意这里面第三步也是有意义的。

### 可重入函数，异步信号安全函数



# 虚拟内存
对物理内存的抽象（增加了映射（哈希））<br>
为什么要用虚拟内存：<br>
1. 简化内存管理，每个进程可以给出相同的地址空间分布
2. 隔离地址空间，每个进程实际上在内存中又是隔离的
3. 可以作为某种缓存

# 几个概念：<br>
页：大小一般为4kb，VM的基本单位，其具体的映射关系由页表管理。   
页表：PT，其由一个个页表条目（PTE）构成，每个进程都有一个，表明该进程的虚拟内存与真实物理内存的映射关系。**注意页表PTE本身也保存在内存中**<br>
页表条目：由一个有效位加n位地址构成，其中，n为地址又可以被分为p为的偏移量和n-p位的虚拟页号。这个虚拟页号就是哈希的键，值为对应的物理内存地址或者磁盘地址，其有n-p位。剩下p位则表示在该页中的偏移，如果页的大小为4096个字节，那么p = log2(4096) = 12。

**下面是详细介绍**

## VM as a tool for caching
VM从概念上，是磁盘上的N个连续的字节大小的单元所构成的数组。具体的说，虚拟内存作为硬盘的缓存的含义如下：<br>
<img src="markdown图片/屏幕截图 2023-11-29 170953.png" alt="图片alt" title="图片title"><br>

**实际上，这也算是利用了局部性，利用了一个程序的整体局部性，一个程序的工作集假如全部被拷进内存，那么其读写速度要快的多**  

**另外，一个页表是包含一块数据和偏移量的，因此程序即使读了一小部分，也会把那块整个的从硬盘搬到内存中，这一点依然可以利用局部性的，详细见地址翻译**

当然，实际上由于硬盘也是按块加载进入内存的，所以实际内存存的也会比所需的要多。严格来说这是利用了内存读取硬盘和其他指令的并行来加速的。<br>
<img src="markdown图片/屏幕截图 2023-11-29 171237.png" alt="图片alt" title="图片title"><br>
VM与内存的映射结构如上图。

**因此，内存作为硬盘的缓存，其主要的代价来源于未命中的从而需要从硬盘重新拷贝的时间**<br>
注：也因为硬盘与缓存之间的巨大开销，所以内存总是使用写回策略。

细节介绍：<br>
1. 虚拟内存，物理内存，磁盘的映射关系：
<img src="markdown图片/屏幕截图 2023-11-29 180546.png" alt="图片alt" title="图片title"><br>
如图，每一个基本单元都是虚拟内存的页表大小。我们可以得出下面几点：<br>
A、**每个进程都有自己的虚拟内存，然后该虚拟内存的映射表放在进程的用户态中**<br>
B、图中可以看到虚拟内存页表PT与页表条目（PTE），PTE由有效位和地址构成，图中可以看到它的三种情况：一是有效位为1的，虚拟内存映射到物理内存，即当前访问的磁盘数据在相应地址的物理内存存在。剩下的是有效位为0，一种情况为有地址，则该地址为磁盘地址，即未缓存状态，最后是无地址的（null），即未建立任何映射的未分配状态。

2. 寻找相应内存  
page hit:<br>
<img src="markdown图片/屏幕截图 2023-11-29 205720.png" alt="图片alt" title="图片title"><br>
handler page fault:<br>
<img src="markdown图片/屏幕截图 2023-11-29 194545.png" alt="图片alt" title="图片title"><br>
当寻找的数据不在物理内存而在磁盘中，（如图中的PTE3），即相应的虚拟内存地址的valid为0时，触发以下步骤：<br>
A、触发缺页异常，用户态跳入内核态的缺页处理函数  
B、如果此时内存已经满了，那么缺页处理函数检查缓存策略算法，其给出需要驱逐物理内存中的哪一块（这也意味着映射到该块的虚拟内存PTE要被改变），假设打算驱逐PTE4和对应的VP4  
C、驱逐那一块VP4，并执行写回策略,同时PTE4改成相应的磁盘地址    
D、将寻找的数据放入物理内存中，然后更新页表PTE3，PTE3改成内存地址    
E、最后回到发生中断的那个指令上，这就不会再发生缺页异常了，然后是执行page hit步骤了  
<img src="markdown图片/屏幕截图 2023-11-29 205624.png" alt="图片alt" title="图片title"><br>

allocate page:<br>
假如此时VM中有页未被分配指向任何数据（磁盘或者内存），那它就是未分配的，即malloc调用sbrk函数给这些页分配指向，实际上是给他们的PTE增加了指向磁盘的地址。**只有在访问需要这个磁盘地址的数据时，系统才把磁盘里面的数据拷到内存中**

## VM是一个内存管理工具
VM的增加一层抽象的思想，极大的方便了内存的处理，让每一个进程都能有自己的一个虚拟内存空间。<br>
<img src="markdown图片/屏幕截图 2023-11-29 202638.png" alt="图片alt" title="图片title"><br>
1、如果每一个进程都要在整个内存中分配自己的空间，这将带来无数的问题。而如果将内存划分成小块提供给进程，这又有一大堆问题，例如进程扩容怎么办，进程销毁是不是带来内存浪费，所以说这还不如用个哈希表包装一层<br>
2、另外，链接时，如果要在整个内存中来做，你无法预先知道进程会在那个地址，因此就无法链接<br>

## VM是一个权限管理工具
<img src="markdown图片/屏幕截图 2023-11-29 204105.png" alt="图片alt" title="图片title"><br>

## 地址翻译
1. 翻译的细节  
<img src="markdown图片/屏幕截图 2023-11-29 205321.png" alt="图片alt" title="图片title"><br>
<img src="markdown图片/屏幕截图 2023-11-30 205825.png" alt="图片alt" title="图片title"><br>
如图所示，虚拟地址分为虚拟页号（Virtual page number）和虚拟偏移（virtual page offset）两部分，其中，**虚拟页号用于找到对应的页，虚拟偏移用于在页中找到对应的字节**<br>
从虚拟地址到物理地址的流程：(以page hit为例子)<br>
A、CPU通过指令生成虚拟地址，提供给MMU内存管理单元（memory manage unit）    
B、MMU根据虚拟地址中的VPN获取页表的物理地址  
C、在高速缓存or内存中拿到页表数据PTE  
D、根据页表数据获取页的物理地址，并根据VPO获取页中字节的物理地址  
E、根据物理地址获取物理内存中的字节  
2. 加入缓存的考量  
由于PTE在内存中，所以如果能把最近使用的页表数据也放到缓存中，无疑又进一步优化了时间.让TLB（翻译后备缓冲器）作为页表的缓存：<br>
<img src="markdown图片/屏幕截图 2023-11-30 213832.png" alt="图片alt" title="图片title"><br>

### 多级页表
**页表需要对每一个页提供它的物理内存映射，这是一种需要一一构建的映射**  
现在，分析一下页表的大小，由于页表需要对每一个页，页中的每一个位置做映射，因此，由于地址空间有48，2^48字节，然后页的大小为4kb，2^12字节，因此首先要分清页，这就需要2^36了，然后每一个页的页表数据又是8字节（**8字节，64位，其中12位需要在每个4kb的页中区分每个字节，然后还有36位需要建立与物理地址的映射，剩下的位用于别的信息表示，例如valid等**），2^3的来表示,因此总共需要2^39字节的大小的来存储页表，这是512GB，太大了。

解决方案：<br>
k级页表，其地址翻译的实现方式如下：<br>
<img src="markdown图片/屏幕截图 2023-11-30 171030.png" alt="图片alt" title="图片title"><br>
那么，这种k级页表是如何省内存的呢:<br>
<img src="markdown图片/屏幕截图 2023-11-30 172158.png" alt="图片alt" title="图片title"><br>
一级页表的话，无论某一个虚拟内存有没有映射，都需要保存，即使是null(全0)，而增加多级页表，如二级页表的话，则是某种多级映射，一个null可以代表多个null，某种按需存储，只有存分配了的内存，即（已缓存或者未缓存的）这些的虚拟地址与物理地址的映射即可。<br>

**也就是说，对于VM而言，某一个区域的一部分或全部被用了，那么该部分的页表就不能省了（如图中的代码段和数据段被完全使用，栈段被部分使用），但是如果某部分的没有被使用，那么可以用一个null代替多个null，如图中的堆部分（图中的堆如果VM直接表示需要多个null，多级页表可以用单个null表示）**  
**对于图中栈的情况，属于部分没有被使用，这种情况依然很浪费，所以可以用多级页表减少这种浪费**

## VM在linux系统的实现
在这一节详细分析地址的转换<br>
### 以一个虚拟系统为样例走一遍VM寻址流程
见课本573页开始的内容,笔记如下：<br>

#### 1、如下图的简易内存系统
<img src="markdown图片/屏幕截图 2023-12-04 213714.png" alt="图片alt" title="图片title"><br>
说明如下：
1. 内存按字节寻址，即一个地址对应一个字节的内容。一次访问一个字节，即一次访问获取一个地址的一个字节的内容。
2. 根据物理地址长度，得出该系统内存为2^12
3. 根据页大小为2^6，即需要6位来在一个页内部搜索偏移 **（注意，如果上面一个访问不是针对一个字节，例如针对4个字节，那么一次偏移就是按照4个字节来偏移，那么页大小和偏移表示位的数量就不是一个了）**
4. 我们计算下页表个数，2^12/2^6 = 2^6 = 64，因此需要的页表大小至少为64才能构建虚拟地址到真实地址的映射。而我们看到当前VPN有8位，所以可以有2^8 = 256个PTE，因此实际上多出来的部门是没有作用的，我们只关心前面的64个PTE的内容，他们才有真正的物理地址映射
<img src="markdown图片/屏幕截图 2023-12-04 215733.png" alt="图片alt" title="图片title"><br>
图中可以看到VPN对应存储的PPN。<br>
5. TLB作为PTE的缓存，其地址即VPN，按照图中说法，其四路组相连，其有4组，每组4行（块），每行（块）存储一个PPN（即VPN对应的物理页地址）。因此，其组索引有两位，即下图的TLBI，TLBT用于区分映射到同一组的不同PTE的数据。
<img src="markdown图片/屏幕截图 2023-12-04 215522.png" alt="图片alt" title="图片title"><br>
图中，“位”即块索引，标记位（实际为6位）即tag，PPN（实际为6位）为物理页地址，有效位是单独出来的。<br>
6. L1cache为直接映射缓存，其地址为真实物理地址（页+偏移）。其1组就1行，每行存储4个字节，总共16组。因此，可以得到组索引4位，每行（块）的偏移2位，还剩下的6位即tag，区分映射到同一组的不同的内存块。
<img src="markdown图片/屏幕截图 2023-12-04 215859.png" alt="图片alt" title="图片title"><br>
缓存切片说明：<br>
可以看到，物理地址12位，组索引4位，即图中左边的0到F，标记位**注意为2进制的6位**，每行（块）有4个块，每个块1个字节（8位）。

#### 2、加入要查找某个CPU生成的VM，流程为：
1. CPU给出虚拟地址0x03d4<br>
   分解该地址，03d4 = 0000 0011 1101 0100  
   后6位为页偏移，010100 = 14
   再6位为VPN，001111 = 0F
2. 根据0F，寻找TLB，命中，得到PPN，不命中则要到内存的PTE中寻找
   0F = 0000 1111，11 = 3为块索引，000011 = 3为tag，取出缓存中的PPN：0D
3. 根据PPN+PPO，得出真实物理地址
   **注意**，0D = 0000 1101，而PPN实际是6位，因此去001101，然后PPO = VPO = 010100，因此实际组成物理地址为001101010100 = 354，不是0D0F。
4. 根据真实物理地址，在缓存中寻找，命中

以上就是全流程。

### coreI7系统设计特点
1. L1cache，组索引大小+块内偏移位大小 = 内存段内地址偏移（VPO）位大小,**这样做的好处在于，在通过VPN寻找到物理页地址前，就能把VPO送入cache来寻找组索引和块内偏移，之后只要等待PPO就好，PPO即tag**
2. 四级页表的寻址：<br>
   页表条目格式如下：<br>
   <img src="markdown图片/屏幕截图 2023-12-05 202602.png" alt="图片alt" title="图片title"><br>
   其中，40位的页表物理基地址，**注意corei7系统页大小4kb，物理地址52位，虚拟地址48位,52=40+12**。<br>
   每一级页表的基地址 + VPN的偏移量 = 页表的地址<br>
   注意是物理基地址为12-52的位，加偏移量加到这些位上面<br>
   第一级页表的基地址位于内核态中，使用时会放到CR3寄存器中，1-3级的页表的地址中存储下一级页表的物理基地址，第4级存储真实页表的物理基地址。<br>

### linux虚拟内存系统：
如图所示：<br>
<img src="markdown图片/屏幕截图 2023-12-05 211656.png" alt="图片alt" title="图片title"><br>
注：地址有效的为低48位，内核态高位均16位为1，用户态高16位均为0。<br>
1. 内核态中，对每个进程都一样的部分：内核代码数据，代表内核的控制代码等，以及一个直接映射到物理内存的内存段
2. 内核态中，每个进程独有的，与进程相关的上下文。

**也就是说，内核态有公用部分和私有部分**

**linux虚拟内存区域（段）（area_struct）**<br>
<img src="markdown图片/屏幕截图 2023-12-06 154329.png" alt="图片alt" title="图片title"><br>
观测此结构，内核态中，每个进程的上下文区域有一个mm指针指向内核态中的mmstruct框架，该框架中pgd为一级页表基址，mmap指向的链表（或者树）称为区域结构,他划分了各个内存区域**（也就是段segment）**。区域结构作用如下：<br>
<img src="markdown图片/屏幕截图 2023-12-06 154921.png" alt="图片alt" title="图片title"><br>
该链表（或者形成树）的节点属性除了指向别的节点，还包括映射的区域的属性，即一个虚拟内存区域的起始和终止地址，读写权限，共享性等。

**访问一个虚拟地址A，发生缺页异常后，内核的异常处理程序的处理流程**
1. 看A是否合法，即A是否已经在某个区域结构中了，也就是遍历链表寻找A所在的vm_end <= A <= vm_start，如果A都不满足，则属于段错误。**根据这个链表的需求和性质，实际上该链表一般以红黑树的形式存在**
2. 试图访问的内存是否有权限，经过上面的遍历，A被发现在某个区域结构中，那么对A执行的命令（读，写，执行）是不是被允许的？如下图所示的问题会导致不合法的访问。<br>
<img src="markdown图片/屏幕截图 2023-12-06 160609.png" alt="图片alt" title="图片title"><br>
1. 经过上述流程，A的访问是合法且满足权限的，那么唯一剩下的缺页异常可能性就是该页不存在与内存中，而是在磁盘中，接下来就执行内存换页流程就行了<br>
<img src="markdown图片/屏幕截图 2023-12-06 161756.png" alt="图片alt" title="图片title"><br>

### linux内存映射：
<img src="markdown图片/屏幕截图 2023-12-06 163652.png" alt="图片alt" title="图片title"><br>
注：上述匿名文件一般用途为未初始化区域的内存映射（如bss段）<br>

这种虚拟内存对于磁盘上的文件的映射有什么作用呢？<br>
1. 实现共享对象：<br>
   将不同进程的虚拟地址映射到同一物理地址
2. 实现private copy on write：COW（私有写的共享对象）<br>
   即该段内存，读的时候各进程之间共享。写的时候，各进程视其为私有，写该段内存时，实际上复制该段内存并写（更新）<br>
   **COW的关键应用在于fork(),让fork实际无需复制值，页表仍然相同，相同的虚拟地址指向原有的物理内存对象，仅仅是PID不同**<br>
   **因此，父子进程读的时候，实际读的同一虚拟地址和物理地址，而开始写的时候，对应的页就会被复制然后更新。**
3. execve函数：也是运用了上述的**用时处理**的思想<br>
   <img src="markdown图片/屏幕截图 2023-12-06 215240.png" alt="图片alt" title="图片title"><br>
   如图，execve不创建新的进程，但是其更新内核态中的area_struct结构，然后根据程序各段的性质，分为共享的或者是私有写时复制的。<br>
   **注意，execve函数仅仅设置了areastruct和页表，实际的页并没有加载到内存中（即仅仅创建了映射）**<br>
   **在程序执行过程中，自然的出现异常，然后再加载**

另外mmap函数：可以在用户态自行建立内存映射的函数，其用处在于手动将硬盘上的文件映射到虚拟内存地址段中。

# 动态内存分配
<img src="markdown图片/屏幕截图 2023-12-08 112211.png" alt="图片alt" title="图片title"><br>
系统将内存分为各个块（块的单位至少为1字节）,不同块有已分配allocated属性和空闲free属性

## 显式分配器
## malloc:
**void\* malloc(size_t size)**:  
size_t：typedef size_t unsigned long  
**作用为，在堆上分配一个大小至少为1字节的空间，具体大小为size的大小(一般这样表达：20 * sizeof(int),即80但是这样写好一点)，返回一个指向该块内存第一个字节的地址的指针**<br>
**实际上，void*作为通用指针返回，它可以被返回给任意类型的指针，此时地址虽然是第一个字节，但是实际该指针包含的指向范围就大了**<br>  
例如下面的代码：  
int \*a = (int*)malloc(8 * sizeof(int))  
一般这样使用malloc，不要写成8 * 4比较好，然后返回指针类型为void*，可以转成我们需要的指针类型，此时a就指向被分配内存的第一个字节。<br>

## free:
void free(void *p),p为malloc中指向被分配的内存的第一个字节的指针。<br>

## 相关函数一览：
<img src="markdown图片/屏幕截图 2023-12-08 154501.png" alt="图片alt" title="图片title"><br>

## 如何实现malloc和free：
<img src="markdown图片/屏幕截图 2023-12-08 161159.png" alt="图片alt" title="图片title"><br>
图中的malloc以及free的分配方式，注意图中一个块是一个字（4字节），malloc会按照4字节进行对齐，例如申请14个字节，malloc会提供16个字节<br>
另外，注意free过后的指针（如图中p2），此时p2实际上是野指针。

### malloc的约束：
<img src="markdown图片/屏幕截图 2023-12-08 161420.png" alt="图片alt" title="图片title"><br>

### malloc的实现指标：
1. 吞吐量，malloc和free执行次数/s
2. 峰值内存利用率：<br>
   **有效载荷P**，包含两个意思，一个是分配块中，有效的部分，例如由于对齐需要分配16个字节，实际只要14个字节；另一个是分配了5块，之后释放了中间的3块，由于不能影响块的位置，所以此时堆的最高峰为5，而P为2。<br>
   **堆的最高峰H**：Hk意思为第k个请求后，堆中已分配的内存的最高位地址。<br>
   因此利用率Uk = Pk/Hk

**内存碎片**：实际上，正如P中的两个意思：<br>
1、**内部内存碎片**；块的内存对齐要求。或者分配器有最小块大小（例如最小分配16字节），或者分配器需要在块中设计自己的数据结构（例如程序要求16字节，分配器另外需要4字节来存储自己需要的数据结构）<br>
2、**外部内存碎片**：即块中空闲块不连续，是的即使总空闲空间满足需求，但因为空闲块不连续，所以不能分配。

### 设计分配器需要考虑的几个要点：
1. free多少，free如何知道块的大小：<br>
接下来，如果要考虑内存使用率，就意味着重复利用内存块，那么，就有一下几个问题：
2. 如何跟踪空闲区域
3. 某次分配中，空闲区域大于分配区域的话，如何处理空闲区域的剩余空间
4. 有许多空闲区域适合分配，选择哪一个
5. 合并问题，如何处理被释放的块，其是不是要与周围的空闲区域合并。<br>

### 解决方案：
1. free多少：一般在malloc的时候，如malloc16个字节，实际上前4个字节存储malloc了多少。

**各块需要空间来存储每个块自身的信息，一个常用的处理方法图下图所示：**
<img src="markdown图片/屏幕截图 2023-12-08 175253.png" alt="图片alt" title="图片title"><br>
如图所示,对于每一个分配的内存块，使用前面的块区域来表达该块的信息（**用后三位表达是否分配，这使得每块大小至少为8的倍数，即双字对齐**），后面的填充则由于前面所说的8字节，即双字对齐，即使想要8个字节（注意块头部4个字节），总长度也有16个字节<br>

较难问题的解决：<br>
2. 如何跟踪空闲区域：<br>
A、隐式链表，如上图，如果每一个空闲/分配的区块大小都被定义，则实际上就可以通过遍历这些块寻找到空闲区域，实际上是一个不需要链表表示的链<br>
B、显式链表，  
更改块头部，真实的实现一个链表（双向或单向），将各个空闲区域链接起来而不包括分配区域  
<img src="markdown图片/屏幕截图 2023-12-10 171246.png" alt="图片alt" title="图片title"><br>
图中显示了另外两个较为高级且复杂的方法：  
C、类似桶，将空闲区域大小在不同范围内的装入不同的list中  
D、用树实现空闲区域块大小的排序  

基于隐式链表的问题解决方案：<br>
3. 合并块：
<img src="markdown图片/屏幕截图 2023-12-10 200004.png" alt="图片alt" title="图片title"><br>
图中，-2：1111……111110，将标志位改为0，然后分析下一个区域，这样带来问题是无法在常数时间内找到前一项，因此需要增加向前遍历的可能：<br>
<img src="markdown图片/屏幕截图 2023-12-10 200859.png" alt="图片alt" title="图片title"><br>
如图，办法就是把块头的信息在块尾也复制一份，因此这个边界信息标记便可以在**需要free的块向前偏移一个字找到**

基于显式链表的malloc，free：<br>
显式空闲链表将空闲空间连接起来<br>
free区域的合并是主要难点，详细过程见课程。<br>

分离链表设计：
即前述图的C设计方案。以显式空闲链表为基础，将不同空闲区域大小的分别形成链表。这基本上是最佳的方式，具备不同的尺寸等级让分配变得非常迅速。

## 垃圾回收：
将内存抽象为如下有向图：<br>
<img src="markdown图片/屏幕截图 2023-12-11 114832.png" alt="图片alt" title="图片title"><br>
图中，Root为栈中的指向堆的指针，堆中各节点为已分配内存块，其中已分配的堆内存可能包含指向其他堆内存的节点。<br>
因此，图中存在可达和不可达的节点，不可达的堆内部节点即视为垃圾<br>
**C中的保守垃圾回收策略**：
当malloc分配内存不够的时候，执行下列步骤：
1. Mark，从根节点（栈中指向堆的指针开始），给能到达的节点加上标记（可选择在块头部的末三位中选择一个标记位）
2. sweep：从堆头部开始扫描整个堆，发现未标记的已分配区域即是垃圾，将其free。

### 重要问题，指向堆的指针判断：
1. 如何判断该4字节/8字节变量就是指针
2. 如果该指针指向堆的已分配块的中间位置，怎么找到区域头部<br>
解决方案：对于后一个问题，可以利用一个平衡二叉搜索树，在malloc分配时，将分配的指针放入树中。这样在垃圾回收时，每一个可能是指针的4字节/8字节值都会在树中找到其头部。  
**这就产生了一个问题，可能有别的整数也恰好能在这个树中找到匹配的节点**，因此，如果假设它是指针的话，那么就会出现某些并非指针指向的堆内存节点被指向了。  
因此，这就是所谓保守的垃圾回收，第一个问题无法真正解决的根本原因是地址和整数没有根本上的区分。  

## C中与内存有关的错误介绍：
<img src="markdown图片/屏幕截图 2023-12-11 161339.png" alt="图片alt" title="图片title"><br>
从符号开始，根据运算符顺序解析。  
例如int \*p[13],p是一个13大小的数组，每个数组的值为int*类型。  

几个容易被忽视的问题：<br>
1. 忽视指针类型大小：
   <img src="markdown图片/屏幕截图 2023-12-11 162653.png" alt="图片alt" title="图片title"><br>
   int和int*类型大小在32位相同，64位不同
2. 忽视指针加法重载：
   <img src="markdown图片/屏幕截图 2023-12-11 162604.png" alt="图片alt" title="图片title"><br>
   图中p += sizeog(int)，p为指针情况下实际上加了16
