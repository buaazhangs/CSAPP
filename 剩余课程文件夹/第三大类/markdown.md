# 存储器层次结构
## Lecture11：内存层次结构
传统无缓存的内存读取：<br>
<img src="markdown图片/屏幕截图 2023-11-16 162029.png" alt="图片alt" title="图片title"><br>
内存离寄存器过远了<br>
传统无缓存硬盘读取：<br>
1. CPU提供逻辑块地址给硬盘
2. 硬盘控制器传输信息到内存中，**这个过程cpu不会关注**
3. 硬盘控制器发送中断信息给CPU。<br>
第二步这么做的原因在于，硬盘读写速度过慢，因此硬盘读写时间CPU用来做其他事。**即某种进程阻塞**

## 如何缓解CPU速度与存储速度的不一致：
程序的局部性：程序更可能使用接近其“最近使用的数据或地址”的那些或地址。<br>
时间局部性：某时刻访问的内存地址，很近的时刻可能再次访问<br>
空间局部性：某时刻的访问地址，很近的时刻很可能访问邻近的地址<br>
例如下述程序，体现了数据和指令的时间空间局部性。
<img src="markdown图片/屏幕截图 2023-11-16 173553.png" alt="图片alt" title="图片title">
因此，我们要尽量写出适合局部性的程序，例如二维三维数组的相加。  

## 利用上述局部性，实现高速缓存
如下面的存储器层次结构：<br>
<img src="markdown图片/屏幕截图 2023-11-16 201327.png" alt="图片alt" title="图片title"><br>
每个上层从它的下一层检索数据，**家-学校-书包比喻，书包即缓存**这就是一种缓存思想：<br>
例如，可以把内存视为硬盘数据的缓存，因此在cpu读取硬盘数据期间，只有硬盘和内存的交互，cpu可以干其他事情。<br>
缓存基本原理：分块预先存储上层内存中内容：<br>
<img src="markdown图片/屏幕截图 2023-11-16 204031.png" alt="图片alt" title="图片title"><br>

cpu访问内存流程：  
命中(hit):如访问第14块，则可以把第14块直接给寄存器<br>
未命中(miss):如上图假如需要第4块内存，先发现cache中没有第4块，则cache向内存申请第4块，然后（缓存淘汰策略，如LRU）覆盖最近最少使用缓存（图中的第8块）。<br>
缓存不命中原因：<br>
1. 冷启动时，cache为空不命中
2. 空间不命中，某一程序的工作集大于缓存容量，必然无法每个都命中
3. 冲突不命中
具体的见后。

### 对于硬盘这种放入内存是可以获知的地址，但是对于内存访问地址未知，如何把内存中更可能被访问的放入高级缓存中？
利用局部性原理，访问某一地址内存时，把那一部分内存都放入缓存中。这就是为什么上面的图按块划分的原理，必然某一时刻cpu访问的内存地址在第4块，就可以把第4块的整个都放入缓存。<br>