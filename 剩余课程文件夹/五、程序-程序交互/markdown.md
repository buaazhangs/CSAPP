# 与操作系统对接的IO

## unixIO
unix文件基本属性：  
1. 文件内容：一系列字节序列
2. 进程对文件的处理：
<img src="markdown图片/屏幕截图 2024-01-15 111820.png" alt="图片alt" title="图片title"><br>
**在进程对文件的处理中，依然是内核控制着文件的各种属性**

文件类型：  
普通文件，目录，socket等  
另外，不在本课程中讲述的还有：通道文件，符号链接，外接设备等。<br>

## 1.普通文件
普通文件的高层分类：指的是每一个存储的字节的含义，这个含义不是在操作系统层面，而是在存储的内容是什么的层面，
<img src="markdown图片/屏幕截图 2024-01-15 184417.png" alt="图片alt" title="图片title"><br>
基于存储字节的含义不同，文本文件中这些字节只包含ascii和unicode编码（即其他的非这些编码的字节不存在）。二进制文件这些字节包含所有可能的值，例如图像文件等。

## 2.目录文件
<img src="markdown图片/屏幕截图 2024-01-15 185535.png" alt="图片alt" title="图片title"><br>
每个目录文件都至少包含它自身和它的父类的地址。

文件层次架构：<br>
<img src="markdown图片/屏幕截图 2024-01-16 121429.png" alt="图片alt" title="图片title"><br>
cwd:current work directory,图中显示了当前工作目录下寻找另一目录的方式。

## 3.低级unix文件操作
1. 进程中打开文件等操作：  
   见程序代码<br>
   **文件描述符：**<br>
   用于在某一进程中标识所打开的文件。<br>
   另外，linux打开的进程中，默认0，1，2分别代表stdin，stdout，stderr。
2. 注意关闭文件也会有错误，尤其是**多线程程序中的情况**。
3. 读文件，**注意，读文件后才是把文件描述符所指定的文件读入内存**
<img src="markdown图片/屏幕截图 2024-01-19 214201.png" alt="图片alt" title="图片title"><br>
另外，它读取位置从当前文件的文件位置开始（存储于内核态中），读取一定数量字节后，更新该文件位置。<br>
**不足值：指请求的字节数小于实际写入/读取的字节数量。**  
写文件同样，也有上述不足值。不足值常出现在网络编程中，以及来自终端的未知字节数量的输入。

## 各种模式的IO处理程序
最简单的IO程序：  
1. 代码中的stdin.c程序，这个程序运行看起来是输入一行然后输出一行，实际上该代码依然是读一个字节输出一个字节，输入一行才相应是因为终端程序的接口的原理。
2. **strace工具**  
   strace可以监控某个程序的所有系统调用:  
   strace -e trace=write ./cpstdin

stdin.c程序是一种无缓存的读法，过多的调用了系统函数。针对不足值，可以有更好的处理方式。  

## 详解short count不足值  
不足值的来由与后果：请求的字节数小于实际写入/读取的字节数量
1. 比如，文件复制中，缓冲区大小不足导致得多次写入
2. EOF情况（文件结尾EOF，或者终端的一行文字）不足值：
   read遇到EOF，先返回不足值，下一次调用返回0；例如剩余20个字节到EOF，读50个字节，第一个read返回20，再下一个read返回0。**即检测EOF需要用上述的方法保证多读一次read**
3. 网络数据包不足值  
   网络数据包大小一般为1500个字节，因此read和write都有可能产生与缓存大小不一样的情况，即不足值  
来由：  
<img src="markdown图片/屏幕截图 2024-01-28 162439.png" alt="图片alt" title="图片title"><br>
不良后果：  
<img src="markdown图片/屏幕截图 2024-01-28 162556.png" alt="图片alt" title="图片title"><br>
可以参见程序copy.c  

## robust-IO库：
1. 不带缓冲的IO  
   不带缓冲区，一次性读写文件，什么时候需要什么时候读。   
   正如上面所提到的，不足值的存在影响了copy.c这个文件复制文件过程中的write，而且如果有信号中断的影响，需要另外处理，以robust_read为例：<br>
   <img src="markdown图片/屏幕截图 2024-01-28 175155.png" alt="图片alt" title="图片title"><br>
2. 带缓冲的IO  
   预先读写完文件到内存的缓冲区里面，需要的时候才用。避免了多次调用内核。**因此，与上面的rioreadn不同，带缓冲的IO函数不需要指定一个内存的缓冲区，它有自己的实现逻辑来避免多次的读写文件。**
   它的实现实际如下：<br>
   <img src="markdown图片/屏幕截图 2024-01-28 184518.png" alt="图片alt" title="图片title"><br>
   该结构与文件位置指针的关系显示如下，可以看到其用一个更大的缓冲（already read和read加起来组成了缓冲），其代码实现参见课本。
   <img src="markdown图片/屏幕截图 2024-01-29 180049.png" alt="图片alt" title="图片title"><br>

## 文件的其他信息：
1. 元数据 metadata：  
   stat函数与数据结构

## **unix系统内核是如何描述文件的**：
1. 内核的三个文件描述数据结构：<br>
   <img src="markdown图片/屏幕截图 2024-01-29 215724.png" alt="图片alt" title="图片title"><br>
   均位于进程的内核态，描述符表进程私有，打开文件表记录着vnode表指针（记录文件属性）文件引用数目（refcnt）和**文件位置**，为所有进程共有。<br>
   首先，同一进程内部，可以用不同的文件描述符指向不同的文件，如下,这使得进程内部可以从不同的文件位置打开同一文件：
   <img src="markdown图片/屏幕截图 2024-01-29 220750.png" alt="图片alt" title="图片title"><br>
   另外，打开文件表的进程间共享使得不同进程之间可以从不同的文件位置打开文件<br>
   **父子进程的打开文件表格式**
   fork后，子进程复制父进程内核态中的文件描述符表，因此与父进程指向同一个打开文件表，所以对父子进程中某一进程对文件位置的修改会影响到子进程。<br>
   <img src="markdown图片/屏幕截图 2024-01-29 225325.png" alt="图片alt" title="图片title"><br>
   总之记住两点：<br>
   1.**（记住不同的文件描述符可能指向同一个打开文件表）**  
   2.**同一文件可以有多个打开文件表，并非只有一个**