# 与操作系统对接的IO

## unixIO
unix文件基本属性：  
1. 文件内容：一系列字节序列
2. 进程对文件的处理：
<img src="markdown图片/屏幕截图 2024-01-15 111820.png" alt="图片alt" title="图片title"><br>
**在进程对文件的处理中，依然是内核控制着文件的各种属性**

文件类型：  
普通文件，目录，socket等  
另外，不在本课程中讲述的还有：通道文件，符号链接，外接设备等。<br>

## 1.普通文件
普通文件的高层分类：指的是每一个存储的字节的含义，这个含义不是在操作系统层面，而是在存储的内容是什么的层面，
<img src="markdown图片/屏幕截图 2024-01-15 184417.png" alt="图片alt" title="图片title"><br>
基于存储字节的含义不同，文本文件中这些字节只包含ascii和unicode编码（即其他的非这些编码的字节不存在）。二进制文件这些字节包含所有可能的值，例如图像文件等。

## 2.目录文件
<img src="markdown图片/屏幕截图 2024-01-15 185535.png" alt="图片alt" title="图片title"><br>
每个目录文件都至少包含它自身和它的父类的地址。

文件层次架构：<br>
<img src="markdown图片/屏幕截图 2024-01-16 121429.png" alt="图片alt" title="图片title"><br>
cwd:current work directory,图中显示了当前工作目录下寻找另一目录的方式。

## 3.低级unix文件操作
1. 进程中打开文件等操作：  
   见程序代码<br>
   **文件描述符：**<br>
   用于在某一进程中标识所打开的文件。<br>
   另外，linux打开的进程中，默认0，1，2分别代表stdin，stdout，stderr。
2. 注意关闭文件也会有错误，尤其是**多线程程序中的情况**。
3. 读文件，**注意，读文件后才是把文件描述符所指定的文件读入内存**
<img src="markdown图片/屏幕截图 2024-01-19 214201.png" alt="图片alt" title="图片title"><br>
另外，它读取位置从当前文件的文件位置开始（存储于内核态中），读取一定数量字节后，更新该文件位置。<br>
**不足值：指请求的字节数小于实际写入/读取的字节数量。**  
写文件同样，也有上述不足值。不足值常出现在网络编程中，以及来自终端的未知字节数量的输入。

## 各种模式的IO处理程序
最简单的IO程序：  
1. 代码中的stdin.c程序，这个程序运行看起来是输入一行然后输出一行，实际上该代码依然是读一个字节输出一个字节，输入一行才相应是因为终端程序的接口的原理。
2. **strace工具**  
   strace可以监控某个程序的所有系统调用:  
   strace -e trace=write ./cpstdin

stdin.c程序是一种无缓存的读法，过多的调用了系统函数。针对不足值，可以有更好的处理方式。  

## 详解short count不足值  
不足值的来由与后果：请求的字节数小于实际写入/读取的字节数量
1. 比如，文件复制中，缓冲区大小不足导致得多次写入
2. EOF情况（文件结尾EOF，或者终端的一行文字）不足值：
   read遇到EOF，先返回不足值，下一次调用返回0；例如剩余20个字节到EOF，读50个字节，第一个read返回20，再下一个read返回0。**即检测EOF需要用上述的方法保证多读一次read**
3. 网络数据包不足值  
   网络数据包大小一般为1500个字节，因此read和write都有可能产生与缓存大小不一样的情况，即不足值  
来由：  
<img src="markdown图片/屏幕截图 2024-01-28 162439.png" alt="图片alt" title="图片title"><br>
不良后果：  
<img src="markdown图片/屏幕截图 2024-01-28 162556.png" alt="图片alt" title="图片title"><br>
可以参见程序copy.c  

## robust-IO库：
1. 不带缓冲的IO  
   不带缓冲区，一次性读写文件，什么时候需要什么时候读。   
   正如上面所提到的，不足值的存在影响了copy.c这个文件复制文件过程中的write，而且如果有信号中断的影响，需要另外处理，以robust_read为例：<br>
   <img src="markdown图片/屏幕截图 2024-01-28 175155.png" alt="图片alt" title="图片title"><br>
2. 带缓冲的IO  
   预先读写完文件到内存的缓冲区里面，需要的时候才用。避免了多次调用内核。**因此，与上面的rioreadn不同，带缓冲的IO函数不需要指定一个内存的缓冲区，它有自己的实现逻辑来避免多次的读写文件。**
   它的实现实际如下：<br>
   <img src="markdown图片/屏幕截图 2024-01-28 184518.png" alt="图片alt" title="图片title"><br>
   该结构与文件位置指针的关系显示如下，可以看到其用一个更大的缓冲（already read和read加起来组成了缓冲），其代码实现参见课本。
   <img src="markdown图片/屏幕截图 2024-01-29 180049.png" alt="图片alt" title="图片title"><br>

## 文件的其他信息：
1. 元数据 metadata：  
   stat函数与数据结构

## **unix系统内核是如何描述文件的**：
1. 内核的三个文件描述数据结构：<br>
   <img src="markdown图片/屏幕截图 2024-01-29 215724.png" alt="图片alt" title="图片title"><br>
   均位于进程的内核态，描述符表进程私有，打开文件表记录着vnode表指针（记录文件属性）文件引用数目（refcnt）和**文件位置**，为所有进程共有。<br>
   首先，同一进程内部，可以用不同的文件描述符指向不同的文件，如下,这使得进程内部可以从不同的文件位置打开同一文件：
   <img src="markdown图片/屏幕截图 2024-01-29 220750.png" alt="图片alt" title="图片title"><br>
   另外，打开文件表的进程间共享使得不同进程之间可以从不同的文件位置打开文件<br>
   **父子进程的打开文件表格式**
   fork后，子进程复制父进程内核态中的文件描述符表，因此与父进程指向同一个打开文件表，所以对父子进程中某一进程对文件位置的修改会影响到子进程。<br>
   <img src="markdown图片/屏幕截图 2024-01-29 225325.png" alt="图片alt" title="图片title"><br>
   总之记住两点：<br>
   1.**（记住不同的文件描述符可能指向同一个打开文件表）**  
   2.**同一文件可以有多个打开文件表，并非只有一个**

## IO重定向
dup2函数，改变文件描述符指向的文件打开表。
<img src="markdown图片/屏幕截图 2024-01-29 225325.png" alt="图片alt" title="图片title"><br>
这里注意refcnt为0，内核会释放该文件。

## 标准IO：
标准IO的流缓冲区实际上与RIO的预先加载缓冲区一个含义，见下图：<br>
<img src="markdown图片/屏幕截图 2024-01-30 131132.png" alt="图片alt" title="图片title"><br>


# 网络编程
1. 客户端-服务器的进程思想
2. unix将网络抽象为一个磁盘上的文件，如下：
   <img src="markdown图片/屏幕截图 2024-02-17 171836.png" alt="图片alt" title="图片title"><br>
   可以看出，与外界沟通的网络与磁盘的定位是一样的。
3. 计网简介，简要复习：
   <img src="markdown图片/屏幕截图 2024-02-17 205128.png" alt="图片alt" title="图片title"><br>
## IP协议
1. IP地址，网络大端字节序与小端字节序的转化
2. 域名系统，映射规则：<br>
   **映射实现算法：DNS（domain name system）：**<br>
   一个巨大的分布式系统,分布式数据库。<br>
   **一个域名映射一个或多个IP地址(该服务有多个服务器)，一个IP地址映射一个或多个域名（该IP地址有有多种域名）。**<br>
3. internet连接：
   在IP协议找到地址后，进行TCP传输控制协议，负责两台计算机点对点的协议。**这也被称为socket通信**<br>
   1. 每一个socket包括IP地址和端口号，端口号的存在目的是因为同一个机器上会有多个服务器进程的存在，需要这个16位的端口号加以区分。<br>
   <img src="markdown图片/屏幕截图 2024-03-01 132102.png" alt="图片alt" title="图片title"><br>
   **一般来说，客户端发起连接时，端口是由内核分配的临时端口，链接到服务器的则是well-known知名端口。**<br>
   上述连接，由内核区分不同的端口。<br>
   <img src="markdown图片/屏幕截图 2024-03-02 120913.png" alt="图片alt" title="图片title"><br>

## socket（套接字）接口：
何为套接字，socket简介：<br>
1. 从内核看，他是一个网络的节点
2. 从应用程序角度看，它是一个磁盘文件，一个文件描述符。<br>
<img src="markdown图片/屏幕截图 2024-03-02 121639.png" alt="图片alt" title="图片title"><br>

### 套接字地址结构：
套接字地址是一个16字节的结构，其构成如下图：<br>
<img src="markdown图片/屏幕截图 2024-03-02 123216.png" alt="图片alt" title="图片title"><br>


## socket连接概述：
<img src="markdown图片/屏幕截图 2024-03-02 160249.png" alt="图片alt" title="图片title"><br>

从上层函数开始介绍：<br>
1. getaddrinfo（某种nslookup）:
   将主机名，主机地址；服务名，端口号的字符串表示转化成套接字地址结构。**实际上就是通过DNS获取IP地址和端口号**，反向的查找有getnameinfo函数。
2. socket函数：<br>
   创建一个套接字描述符，返回一个文件描述符。
3. 服务器端bind函数，listen，accept函数：<br>
   bind函数告诉内核把相应的套接字地址和套接字描述符联系起来，**函数接收本机IP地址和端口，返回文件描述符，实际上bind（绑定）函数就是告诉内核，将某个IP地址和端口号和文件描述符对应在一起**<br>
   **另外，注意端口号是所有进程公用的，因此同一端口号是竞争性的，各个进程之间相互竞争，当然，同一端口号也可与多个进程中的文件描述符绑定**
   listen函数告诉内核该进程的该套接字文件描述符对应的是服务器端**通常来说，socket返回的文件描述符，内核会记录它是一个主动描述符，用于客户端。利用listen函数可以将其转化为监听描述符，监听描述符作用是告诉操作系统这个端口的请求正被这个进程所监听**<br>
   accept函数用于做监听列表中获取连接<br>
   **accept函数会返回一个新的文件描述符**，介绍如下：<br>
   <img src="markdown图片/屏幕截图 2024-03-04 172750.png" alt="图片alt" title="图片title"><br>
   1. 客户端，服务器各自使用socket，获得对应的网络连接文件描述符
   2. 客户端通过connect发出连接请求，服务器的内核分析地址找到对应的端口，从而找到对应的accept函数
   3. accept函数fork当前进程（也可能不fork），但总之他创建一个新的文件描述符，这个新的文件描述符与客户端通信。
4. connect函数<br>

PS:**一个进程能够创建多个socket，这多个socket能分别bind多个端口**

5. 读写通信过程
   类似文件读写，直到客户端发出EOF。

**上述过程包装函数**
1. 客户端，openclientfd
2. 服务器端，openlistenfd
   
## web服务器样例，echo服务器与客户端：
<img src="markdown图片/屏幕截图 2024-03-11 214601.png" alt="图片alt" title="图片title"><br>
如图所示，openclientfd连接了某个host：：post，获取了文件描述符cilentfd，自己随机分配了端口。  
然后通过相应的文件描述符获取数据<br>
**如何处理网络数据不能及时到达以及部分到达的问题？**
**使用robust-IO,这能利用缓冲区，以及在未获得服务器数据，或者未达到读取字节要求时的while循环进行等待，来确保获得网络数据。**  

<img src="markdown图片/屏幕截图 2024-03-12 195915.png" alt="图片alt" title="图片title"><br>
while循环中，accept完成连接，获取客户端连接文件描述符，然后根据客户端信息getnameinfo，获取客户端IP。  
echo函数：<br>
包含读取客户端文件描述符和向其中写入。

## HTTP
telnet www.cs.cmu.edu 80

GET /~bryant/test.html HTTP/1.1

Host: www.cs.cmu.edu

可以参考上面这一段的返回

## web
可以理解为一个通过网络连接的分布式文件系统。<br>
通过URL，URL中包括域名（或者IP加端口），和该域名服务器的相应文件。<br>
分析一个动态服务器（例如，服务器文件为可执行文件的情况）的逻辑：<br>
1.首先，服务器端收到连接，通过fork，然后exec执行URL中说明的文件
<img src="markdown图片/屏幕截图 2024-03-12 212844.png" alt="图片alt" title="图片title"><br>
2.可执行文件执行，得到结果发回服务器进程，服务器再发给客户端<br>
<img src="markdown图片/屏幕截图 2024-03-12 213218.png" alt="图片alt" title="图片title"><br>
其中细节：<br>
<img src="markdown图片/屏幕截图 2024-03-12 213415.png" alt="图片alt" title="图片title"><br>
上述细节，实际上被称为CGI，通用网络接口。<br>
1. 客户端通过URL发生request给服务器：<br>
<img src="markdown图片/屏幕截图 2024-03-12 212113.png" alt="图片alt" title="图片title"><br>
2. 服务器通过环境变量传递arguments给子进程。
3. 服务器捕获子进程的输出，通过下述方式。
<img src="markdown图片/屏幕截图 2024-03-12 214031.png" alt="图片alt" title="图片title"><br>