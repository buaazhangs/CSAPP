# 程序机器级表示
### lecture 1
导读部分：介绍c编译，汇编反汇编等  
gdb<br>
汇编基础：  
寄存器：  
%e:32bits, %r:64bits<br>
基础指令:  
mov:三种类型的move，立即数，寄存器与内存，但并不代表有9种可能性，见下图：  
<img src="markdown图片/屏幕截图 2023-11-06 201736.png" alt="图片alt" title="图片title"><br>
上文的地址：  
汇编中寄存器加括号类似于，"\*a",如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-06 202745.png" alt="图片alt" title="图片title"><br>
这种小括号为精简表示，具体的见下图<br>
其中，直接括号代表直接取值(R),D(R)这种代表取R位置后移位D<br>
<img src="markdown图片/屏幕截图 2023-11-06 213943.png" alt="图片alt" title="图片title"><br>
另外，其他的表示形式如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-06 214200.png" alt="图片alt" title="图片title"><br>
lea指令：load effective address(加载有效地址)<br>
leaq src dst<br>
int* p = &x[i],计算x[i]的地址并放入p中。  
当然其还可以被用作计算
指令总结：源在前，目的地在后
<img src="markdown图片/屏幕截图 2023-11-06 210533.png" alt="图片alt" title="图片title"><br>

## lecture2 控制
介绍条件，循环等：这节课把各个指令的方法截图下来即可

### 特殊寄存器：
%rsp:存放栈指针  
%rip:不能直接访问，存储程序执行到哪的指针<br>
condition code：
均为1位的标志量（flag），不能直接设置，根据其他操作设置值,其中4个的细节如下：<br>
CF:carry flag,unsigned溢出标志位。  
SF:sign flag,符号标志位  
ZF:零标志位  
OF:overflow flag,有符号数溢出标志位。<br>
#### 某些汇编指令：
add  
cmp  
test  
#### 读取条件码的值
set系列指令：  
<img src="markdown图片/屏幕截图 2023-11-07 164043.png" alt="图片alt" title="图片title"><br>

由上图，可以得到条件分支语句:<br>


### 以下实现都是用goto视角，goto意味着jump
### ifelse实现：
#### 条件jump：
<img src="markdown图片/屏幕截图 2023-11-07 173101.png" alt="图片alt" title="图片title"><br>


### loops：
基于do while，其他类型可以往这个方向参考。

### switch case：
与if的条件jump不完全相同，switch有一个jump table


## 重点开始，lecture3：程序，函数结构与调用

OS通用思想ABI:application binary interference(应用程序二进制接口)，是机器程序级别的接口。<br>
具体的，如下图所示，**procedure:**一个函数（程序）怎么被调用的，怎么实现数据传输的：<br>
<img src="markdown图片/屏幕截图 2023-11-09 114822.png" alt="图片alt" title="图片title"><br>
1.过程控制:<br>
如何调用一个程序进入其入口，程序结束返回时又要能返回正确的位置<br>
2.过程的数据传输:<br>
如何传入参数和返回参数<br>
3.程序内部的内存管理：<br>
如何在执行过程中分配内存，如何在结束后释放不必要的内存。

### 一、程序（函数）栈结构  
一个抽象的内存区域。在一个可执行文件的过程大于寄存器能存储的量时（大部分都大于，但也有不需要栈帧的），则在内存中保存提出的一个程序执行的各种信息，称为**栈帧**，如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-09 153317.png" alt="图片alt" title="图片title"><br>
注意几点：
1、栈从高地址开始  
2、图中，底部为栈顶，为最低地址，即最后入栈，最上面为高地址<br>
3、注意，栈与代码段地址之间并无特别的联系。

#### 汇编栈操作
1.push:<br>
push src;其中，src为源（寄存器，内存地址，立即数）将源的数据放入dst中。<br>
不需要写dst，dst固定为当前%rsp - 8，即**当前栈指针，往低地址移动一字节**。因此即为将源数据放入栈顶。<br>
2.pop:<br>
pop dst,分为以下三步：<br>
A.读取当前rsp的地址存入某寄存器A中<br>
B.rsp + 8<br>
C.将A地址的值存入dst寄存器中。<br>
注意，以上操作中，**栈顶被释放，并未被“抹去”，其值仍在内存中，只是不再属于栈了。**
### 始终记住，栈与寄存器的区别，寄存器始终是共有的，栈也是共有的但是有rsp控制内存访问。
#### 1、汇编函数转移控制操作
复习几个概念：<br>
%rip，即PC，程序计数器，其指向位置为程序执行位置。
%rsp,栈指针，其指向位置与栈操作相关。<br>
控制部分的设计逻辑在于：要到调用程序的位置；要知道调用程序返回后的执行位置。下面两个执行此功能<br>
1、call<br>
格式为：call "mult2"<br>
实际上call分为三步，类似于jump+push，但是不能用他们替代，因为push和jump不能直接操作ip寄存器。<br>
A.首先，当前栈指针指向栈顶，那么首先%rsp - 8<br>
B.将call指令后面一个指令的地址放入栈顶，call指令地址此时由%rip存储，一般而言call指令5个字节，所以栈顶存的是当前rip地址后5个字节的值。<br>
C.将rip值设为调用函数的起始地址。<br>
如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-09 210253.png" alt="图片alt" title="图片title"><br>
2、ret<br>
ret指令假设栈顶就是你想要跳转的地址<br>
A.pop出栈顶，栈顶内存储的东西进入%rip，%rsp + 8
B.注意原栈顶的值并未特意抹除。  

#### 2、数据传递
6个寄存器，超出规模则存放在栈里面<br>
这6个是固定的，如rdi,rsi,rdx,rcx,r8,r9。参数1~6在进入某个函数之前，**需要把这些参数放入这些寄存器中**。
另外，新的特殊的寄存器，返回ret指令后，返回值存在**rax**里面。

#### 3、临时变量(栈内存管理)
1. 栈上的临时变量（超出6个部分）
2. 如果在函数里调用新的函数，则必须考虑新的函数同样会使用一些寄存器，导致数据的覆盖  

解决方案：  
调用者（caller）和被调者（callee），即调用别的函数和被调用的函数：<br>
如何保证寄存器中的值不被干扰？<br>
A. caller save:调用者保存，调用前把寄存器值保存在栈中。<br>  
B. callee save:被调用者保存，被调用的函数在改变寄存器值之前，先把寄存器值入栈，返回(ret)前出栈重新进入寄存器中。


3. 另外，rsp栈指针，在一个函数调用完成后，一般由编译器计算回调（增高）多少地址，不过，如果遇到函数内可变长度的内存申请，则需要另一个rbp指针

#### 4、以递归理解调用过程