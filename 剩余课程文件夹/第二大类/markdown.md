# 程序机器级表示
### lecture 1
导读部分：介绍c编译，汇编反汇编等  
gdb<br>
汇编基础：  
寄存器：  
%e:32bits, %r:64bits<br>
基础指令:  
mov:三种类型的move，立即数，寄存器与内存，但并不代表有9种可能性，见下图：  
<img src="markdown图片/屏幕截图 2023-11-06 201736.png" alt="图片alt" title="图片title"><br>
上文的地址：  
汇编中寄存器加括号类似于，"\*a",如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-06 202745.png" alt="图片alt" title="图片title"><br>
这种小括号为精简表示，具体的见下图<br>
其中，直接括号代表直接取值(R),D(R)这种代表取R位置后移位D<br>
<img src="markdown图片/屏幕截图 2023-11-06 213943.png" alt="图片alt" title="图片title"><br>
另外，其他的表示形式如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-06 214200.png" alt="图片alt" title="图片title"><br>
lea指令：load effective address(加载有效地址)<br>
leaq src dst<br>
int* p = &x[i],计算x[i]的地址并放入p中。  
当然其还可以被用作计算
指令总结：源在前，目的地在后
<img src="markdown图片/屏幕截图 2023-11-06 210533.png" alt="图片alt" title="图片title"><br>

## lecture2 控制
介绍条件，循环等：这节课把各个指令的方法截图下来即可

### 特殊寄存器：
%rsp:存放栈指针  
%rip:不能直接访问，存储程序执行到哪的指针<br>
condition code：
均为1位的标志量（flag），不能直接设置，根据其他操作设置值,其中4个的细节如下：<br>
CF:carry flag,unsigned溢出标志位。  
SF:sign flag,符号标志位  
ZF:零标志位  
OF:overflow flag,有符号数溢出标志位。<br>
#### 某些汇编指令：
add  
cmp  
test  
#### 读取条件码的值
set系列指令：  
<img src="markdown图片/屏幕截图 2023-11-07 164043.png" alt="图片alt" title="图片title"><br>

由上图，可以得到条件分支语句:<br>


### 以下实现都是用goto视角，goto意味着jump
### ifelse实现：
#### 条件jump：
<img src="markdown图片/屏幕截图 2023-11-07 173101.png" alt="图片alt" title="图片title"><br>


### loops：
基于do while，其他类型可以往这个方向参考。

### switch case：
与if的条件jump不完全相同，switch有一个jump table


## 重点开始，lecture3：程序，函数结构与调用

OS通用思想ABI:application binary interference(应用程序二进制接口)，是机器程序级别的接口。<br>
具体的，如下图所示，**procedure:**一个函数（程序）怎么被调用的，怎么实现数据传输的：<br>
<img src="markdown图片/屏幕截图 2023-11-09 114822.png" alt="图片alt" title="图片title"><br>
1.过程控制:<br>
如何调用一个程序进入其入口，程序结束返回时又要能返回正确的位置<br>
2.过程的数据传输:<br>
如何传入参数和返回参数<br>
3.程序内部的内存管理：<br>
如何在执行过程中分配内存，如何在结束后释放不必要的内存。

### 一、程序（函数）栈结构  
一个抽象的内存区域。在一个可执行文件的过程大于寄存器能存储的量时（大部分都大于，但也有不需要栈帧的），则在内存中保存提出的一个程序执行的各种信息，称为**栈帧**，如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-09 153317.png" alt="图片alt" title="图片title"><br>
注意几点：
1、栈从高地址开始  
2、图中，底部为栈顶，为最低地址，即最后入栈，最上面为高地址<br>
3、注意，栈与代码段地址之间并无特别的联系。

#### 汇编栈操作
1.push:<br>
push src;其中，src为源（寄存器，内存地址，立即数）将源的数据放入dst中。<br>
不需要写dst，dst固定为当前%rsp - 8，即**当前栈指针，往低地址移动一字节**。因此即为将源数据放入栈顶。<br>
2.pop:<br>
pop dst,分为以下三步：<br>
A.读取当前rsp的地址存入某寄存器A中<br>
B.rsp + 8<br>
C.将A地址的值存入dst寄存器中。<br>
注意，以上操作中，**栈顶被释放，并未被“抹去”，其值仍在内存中，只是不再属于栈了。**
### 始终记住，栈与寄存器的区别，寄存器始终是共有的，栈也是共有的但是有rsp控制内存访问。
#### 1、汇编函数转移控制操作
复习几个概念：<br>
%rip，即PC，程序计数器，其指向位置为程序执行位置。
%rsp,栈指针，其指向位置与栈操作相关。<br>
控制部分的设计逻辑在于：要到调用程序的位置；要知道调用程序返回后的执行位置。下面两个执行此功能<br>
1、call<br>
格式为：call "mult2"<br>
实际上call分为三步，类似于jump+push，但是不能用他们替代，因为push和jump不能直接操作ip寄存器。<br>
A.首先，当前栈指针指向栈顶，那么首先%rsp - 8<br>
B.将call指令后面一个指令的地址放入栈顶，call指令地址此时由%rip存储，一般而言call指令5个字节，所以栈顶存的是当前rip地址后5个字节的值。<br>
C.将rip值设为调用函数的起始地址。<br>
如下图：<br>
<img src="markdown图片/屏幕截图 2023-11-09 210253.png" alt="图片alt" title="图片title"><br>
2、ret<br>
ret指令假设栈顶就是你想要跳转的地址<br>
A.pop出栈顶，栈顶内存储的东西进入%rip，%rsp + 8
B.注意原栈顶的值并未特意抹除。  

#### 2、数据传递
6个寄存器，超出规模则存放在栈里面<br>
这6个是固定的，如rdi,rsi,rdx,rcx,r8,r9。参数1~6在进入某个函数之前，**需要把这些参数放入这些寄存器中**。
另外，新的特殊的寄存器，返回ret指令后，返回值存在**rax**里面。

#### 3、临时变量(栈内存管理)
1. 栈上的临时变量（超出6个部分）
2. 如果在函数里调用新的函数，则必须考虑新的函数同样会使用一些寄存器，导致数据的覆盖  

解决方案：  
调用者（caller）和被调者（callee），即调用别的函数和被调用的函数：<br>
如何保证寄存器中的值不被干扰？<br>
A. caller save:调用者保存，调用前把寄存器值保存在栈中。<br>  
B. callee save:被调用者保存，被调用的函数在改变寄存器值之前，先把寄存器值入栈，返回(ret)前出栈重新进入寄存器中。


3. 另外，rsp栈指针，在一个函数调用完成后，一般由编译器计算回调（增高）多少地址，不过，如果遇到函数内可变长度的内存申请，则需要另一个rbp指针

#### 4、以递归理解调用过程


## 重点继续：lecture4：机器级别数据表示
聚合数据表示,数组和结构如何在机器级别实现的。
### arrays:
一维数组，寻址，地址按类型增加等与之前学过的一致。<br>
**如何阅读c的声明：**<br>
从变量名开始内向外，然后右侧先左侧后阅读，例如：<br>
int \*A2[3],首先A2[3],表示一个数组，然后\*A2[3]表示一个指向该数组的指针<br>
还要考虑优先级，有括号优先级更高：<br>
int(\*A3)[3] means A3 是一个指针，指向一个int [3]的数组,\*A3是数组,**A3是数组中的某个数<br>
注意上面，\*(\*A3 + 0x4) == \*A3[1]<br> 
int(\*A4[3])含义为A4为一个数组，每一个值为指针，它们指向int
**[]与[n]的区别**<br>
[]可以视为\*，也就是声明一个指针，但与[n]不同，[]与*一样没有分配空间。
### 二维arrays：
type A[R][C]:  
内存中的行优先存储：  
<img src="markdown图片/屏幕截图 2023-11-14 155504.png" alt="图片alt" title="图片title"><br>

### structs：
内存对齐：  
由于内存一次读取8个字节，所以不同8字节块之间实际上是不同的分块，所以需要字节对齐避免复杂的不同块内存读取操作<br>
1、64位系统，一般都对齐到8个字节<br>
2、注意按顺序进行字节对齐，因此，char a,b;double c;这样的结构体会分配16个字节。而double c;char a,b;这样的可能只有10个字节。<br>

### unions:
用途：<br>
1、假设你只使用union中的一个类型，或者用于不改变字节的类型转换:<br>
例如union中存在一个float和unsigned，类型转换会改变位，但如果union中选取不同类型返回是不会改变位的。  
2、使用char查看大小端。

## 进阶：内存布局：
### Memory layout:<br>
<img src="markdown图片/屏幕截图 2023-11-14 210555.png" alt="图片alt" title="图片title"><br>
另外：
1、代码段还会调用动态链接库（后面链接部分会细说）。  

example：<br>
<img src="markdown图片/屏幕截图 2023-11-14 212836.png" alt="图片alt" title="图片title"><br>
内存布局如下：<br>
<img src="markdown图片/屏幕截图 2023-11-14 213021.png" alt="图片alt" title="图片title"><br>

### Buffer flow(缓冲区溢出):
缓冲区，或简称为缓冲，是计算机内存中的一段临时存储区域，用于在数据在源与目标之间传输时临时存放这些数据。缓冲区的主要目的是处理输入/输出（I/O）操作中的速度不匹配问题，或者处理在数据传输过程中的暂时存储需求。  

缓冲区溢出是一种常见的安全漏洞，发生在当向缓冲区写入的数据量超过了为该缓冲区分配的存储容量时。这种溢出可以覆盖相邻内存区域，导致数据损坏、系统崩溃或安全漏洞。

**就是说，某个区域预先分配（无论是显示分配的内存，还是未显式分配，但是在一定内存区域外就是别的变量的内存），然而填充进该区域的内存超出了这个预先分配的量**  
如下代码:<br>
<img src="markdown图片/屏幕截图 2023-11-15 110033.png" alt="图片alt" title="图片title"><br>
echo函数申请了一个4个字节的char，那么加入gets了超过4个字节会怎么样，我们观察栈：
<img src="markdown图片/屏幕截图 2023-11-15 110846.png" alt="图片alt" title="图片title"><br>
可以看到，栈底属于callecho的部分，其中最顶部即为callecho中下一步程序的地址。另外，我们发现subq了24个字节，也就是说编译器不仅仅分配了4个字节，而是分配了24个字节。因此，当输入23个字符时，末尾的00结尾标识没有溢出到callecho帧内部。<br>
然而，假如超过23个字符，例如下面的25个字符：<br>
<img src="markdown图片/屏幕截图 2023-11-15 111234.png" alt="图片alt" title="图片title"><br>
明显溢出到了callecho的栈帧，直接导致返回地址被修改。<br>
有趣的是，在这个样例中，24个字符会导致程序返回到错误的地址，但却能正确的运行，这就是所谓错误的却导致正确运行的例子：<br>
<img src="markdown图片/屏幕截图 2023-11-15 113200.png" alt="图片alt" title="图片title"><br>
当然，并非总是会如上面的栈帧，但是，总的来说，会发生什么确实是不可预测的。

### 上述缓冲区溢出漏洞，被广泛用于代码注入攻击，解决办法：
1. 避免溢出的函数，如用有最大读取限制的fgets代替gets
2. 操作系统层面保护：  
   A.  
   ASLR：地址空间布局随机化。  
   见演示程序ASLR,创立了各种类型变量，观察其地址。  
   B.<br>
   地址权限技术：
   可写，可读，可执行。<br>
   只保存代码段代码为可执行的，堆栈中的代码均只是可读和可写，不可执行。<br>
   C.金丝雀技术<br>
   canary:如上文中的gets函数，我在栈指针的高8位出存一个canary，然后另有一个寄存器fs存同样的canary，gets执行完后，如果溢出了，例如超过8个字节，就会影响到栈中的canary，栈中canary与fs比较出问题说明缓冲区溢出。<br>
   **破解A和B：**  
   蛮力技术破解A：在栈空间中加入一大坨无真正操作的指令，这样即使随机化了攻击代码的地址，也可以在跳到某地址后执行指令滑到攻击代码处<br>
   rop技术：伪造ret指令（c3），提前返回，返回到代码段的地址，也就是不把入侵代码放在栈内而是直接放在程序段中。  